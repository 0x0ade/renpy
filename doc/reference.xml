<?xml version="1.0" encoding="UTF-8" ?>
<doc>
<title>The Ren'Py Reference Manual</title>

<p>
<b>Last Updated:</b> <!-- date -->
</p>

<toc/>

<p>
Ren'Py is a programming language and runtime, intended to ease
the creation of visual-novel type games. It contains features
that make it easy to display thoughts, dialogue, and menus; to
display images to the user; to write game logic; and to support
the saving and loading of games. Ren'Py tries to be like an
executable script, allowing you to get a working game without much
more effort than is required to type the game script into the
computer.

</p><p>

Ren'Py is implemented on top of Python, and that python heritage
shows through in many places. Many Ren'Py statements allow
Python expressions to be used, and there are also Ren'Py
statements that allow for the execution of arbitrary python
code. Many of the less-used features of Ren'Py are exposed to
the user by way of Python. By only requiring use of the simplest
features of Python, it's hoped that Ren'Py will be usable by
all game authors.

</p>

<h3>A Simple Ren'Py Script</h3>

<p>

The following is a simple but complete Ren'Py script. The colors
are added to make it easier to read, and aren't part of the
script proper.

</p>

<example>
init:
    image bg whitehouse = "whitehouse.jpg"
    image eileen happy = "eileen_happy.png"
    image eileen upset = "eileen_upset.png"
    $ e = Character('Eileen')

label start:

    scene bg whitehouse
    show eileen happy

    e "I'm standing in front of the White House."

    show eileen upset

    e "I once wanted to go on a tour of the West Wing, but you have to
       know somebody to get in."

    "For some reason, she really seems upset about this."

    e "I considered sneaking in, but that probably isn't a good idea."
</example>

<p>
This example, shows many aspects of a Ren'Py script. The first
four lines of the script serve to load in three images. After
the label indicating the start of the game, a character is
declared. The script then proceeds to display a picture of a
character on top of a background image, and to have the
character say two lines of dialogue, changing her picture in
between. The POV character then thinks a line of dialogue,
before the character says her final line.

</p><p>

We'll go into detail into what each of the statements here does
over the course of this tutorial. For now, however let me just
point out that the first 6 statements initialize the game, while
the last 7 (starting with "scene") show images and display
dialogue. As such, the bulk of a game is more like the last 7
then the first 6.

</p><p>

Of particular note is that a keyword isn't required to introduce
dialogue. This allows visual novels consisting mostly of
dialogue to be expressed in a concise form.

</p>

# START NOPAR
<h2>The Ren'Py Language</h2>

This section describes the Ren'Py language, and the functions found in
that language.

<h3>Script, Line, and Block Structure</h3>

Ren'Py scripts consist of one or more .rpy files. These script files
may be read in any order, and all of them together make up a Ren'Py
script. Please see ''TODO'' for information about where Ren'Py
searches for .rpy files.

Each of these files is divided into a series of <b>logical
line</b>s. The first logical line of a file begins at the start of a
file, and another logical line begins after each logical line ends,
until the end of the file is reached. By default, a logical line is
terminated by the first newline encountered. However, a line will not
terminate if any of the following are true:

<ul>
<li>The newline is immediately preceded by a backslash. In this case,
the backslash is removed, and the newline is ignored.</li>

<li>An opening parenthesis, bracket, or brace has been encountered without
encountering the corresponding closing character.</li>

<li>The newline occurs within a string.</li>
</ul>

Ren'Py script files also can include <b>comment</b>s. A comment begins
with a hash mark that is not contained within a string, and continues
to, but does not include, the next newline character. Some examples
are:

<example>
# This line contains only a comment.
scene bg whitehouse  # This line contains a statement as well.
</example>

If, after eliminating comments, a logical line is empty, that logical
line is ignored.

Logical lines are then combined into <b>blocks</b>. Two logical lines
are in the same block if the lines have the same indentation preceding
them, and no logical line with a lesser amount of indentation occurs
between the two lines. Indentation may only consist of spaces, not
tabs. In the following example:

<pre>
line 1
    line a
    line b
line 2
    line c
    line d
</pre>

In this example, here are three blocks. One block contains lines 1 and
2, another lines a and b, and the third contains lines c and d. This
example can also serve to illustrate the concept of a <i>block
associated with a line</i>. A block is associated with a line if the
block starts on the next logical line following the line. For example,
the block containing lines a and b is associated with line 1.

There are three kinds of blocks in an Ren'Py program. The most common is a block containing Ren'Py statements. Blocks may also contain menuitems or python code. The top-level block (the one that contains the first line of a file) is always a block of Ren'Py statements. 

<h3>Syntax Constructs</h3>

Before we can describe Ren'Py statements, we must first describe a
number of syntactic constructs those statements are built out of. In
this subsection, we describe such constructs.

<b>Keyword</b>s are words that must literally appear in the source
code. They're used ito introduce statements, or to delimit parts of
statements. You'll see keywords throughout the descriptions of
statements. In grammar rules, keywords are in quotes. The keywords
used by Ren'Py are:

<pre>
at
call
elif
else
expression
hide
if
image
init
jump
label
menu
onlayer
pass
python
return
scene
set
show
with
while
</pre>

A <b>name</b> consists of a letter or underscore (_) followed by zero
or more letters, numbers, or underscores. For this purpose, unicode
characters between U+00a0 and U+fffd are considered to be letters. A
name may not be a keyword.

A <b>simple_expression</b> is a python expression that starts with a
name, a string, or any python expression in parenthesis. This may be
followed by any number of the following:

<ul>
<li>A dot followed by a name.</li>
<li>A parenthesized python expression.</li>
</ul>

A <b>python_expression</b> is an arbitrary python expression that may
not include a colon. These expressions are generally used to express
the conditions in the if and while statements.

An <b>image_name</b> consists of one or more names, separated by
spaces. The first name in an image_name is known as the
<b>image_tag</b>.

<pre>
image_spec -&gt; image_name ( "onlayer" name) ( "at" transform_list )? ( "with" simple_expression )?
</pre>

An <b>image_spec</b> consists of an image name, optionally an `onlayer`
keyword, optionally an `at` clause followed by a comma-separated list
of simple_expressions that evaluate to functions that transform
displayables to displayables, and optionally a `with` clause.

<b>Grammar Rules.</b> We will be giving grammar rules for some of the
statements. In these rules, a word in quotes means that that word is
literally expected in the script. Parenthesis are used to group things
together, but they don't correspond to anything in the script. Star,
question mark, and plus are used to indicate that the token or group
they are to the right of can occur zero or more, zero or one, or one
or more times, respectively.

If we give a name for the rule, it will be separated from the body of
the rule with a crude ascii-art arrow (-&gt;).

<h3>Call Statement</h3>

The call statement is used to transfer control to the statement with
the given name. It also pushes the name of the statement following
this one onto the call stack, allowing the return statement to return
control to the statement following this one.

<pre>
call_statement -&gt; "call" name ( "from" name )?
call_statement -&gt; "call" "expression" simple_expression ( "from" name )?
</pre>

If the <kbd>expression</kbd> keyword is present, the expression is
evaluated, and the string so computed is used as the name of the
statement to call. If the <kbd>expression</kbd> keyword is not present, the
name of the statement to call must be explicitly given.

If the optional from clause is present, it has the effect of including
a label statement with the given name as the statement immediately
following the call statement. An explicit label is required here to
ensure that saved games with return stacks can return to the proper
place when loaded on a changed script. From clauses should be included
for all calls in released games.

As from clauses may be distracting when a game is still under
development, we provide with Ren'Py a program, called <kbd>add_from</kbd>, that
adds from clauses to all bare calls in any game directory. It can be
found in <kbd>tools/add_from</kbd>, although it needs to be run from the base
directory. The easiest way to do this on windows is by running
<kbd>tools/game_add_from.bat</kbd>. It should be run before a final release of
your game is made. Be sure to make a backup of your game directories
before running <kbd>add_from</kbd>. Also note that add_from produces .bak files
for all files it can change, so delete them when you're satisfied that
everything worked.

<example>
e "First, we will call a subroutine."

call subroutine from _call_site_1

# ...

label subroutine:

    e "Next, we will return from the subroutine."

    return
</example>

<h3>Hide Statement</h3>

The hide statement is used to hide an image from the screen, based on a supplied image_spec.

<pre>
hide_statement -&gt; "hide" image_spec
</pre>

A hide statement operates on the layer supplied in the
<kbd>onlayer</kbd> clause of the image_spec, defaulting to "master" if
no such clause has been supplied. It finds an image beginning with the
image tag of the image name in the image_spec, and removes it from
that layer.

Please note that the hide statement is rarely used in practice. Show
can be used by itself when a character is changing emotion, while
scene is used to remove all images at the end of a scene. Hide is only
necessary when a character leave at the end of a scene.

<h3>If Statement</h3>

The if statement is used to conditionally execute a block of statements. 

<pre>
if_statement -> "if" python_expression ":"
elif_clause -> "elif" python_expression ":"
else_clause -> "else" ":"
</pre>

The if statement is the only statement which consists of more than one
logical line in the same block. The initial if statement may be
followed by zero or more elif clauses, concluded with an optional else
clause. The expression is evaluated for each clause in turn, and if it
evaluates to a true value, then the block associated with that clause
is executed. If no expression evaluates to true, then the block
associated with the else clause is executed. (If an else clause
exists, execution immediately continues with the next statement.) In
any case, at the end of the block, control is transferred to the
statement following the if statement.

<example>
if points >= 10:

   e "Congratulations! You're getting the best ending!"

elif points >= 5:

   e "It's the good ending for you."

else:

   e "Sorry, you're about to get the bad ending."
</example>

<h3>Image Statement</h3>

The image statement is used to declare images to Ren'Py. Image
statements can only appear in <a href="#Init Statement">init blocks</a>.

<pre>
image_statement -> "image" image_name "=" python_expression
</pre>

An image statement binds an image name to a displayable. The
displayable is computed by the supplied python expression, with the
result of the expression being passed to the <ref>im.Image</ref>
function in loose mode. This means that if the assignment is a single
string, it is interpreted as an image filename. Displayables are
passed through unmolested. Once an image has been defined using an
image statement, it can be used by the scene, show, and hide
statements.

<example>
init:
    image eileen happy = "eileen/happy.png"
    image eileen upset = "eileen/upset.png"
</example>


<h3>Init Statement</h3>

The init statement is used to execute blocks of Ren'Py statements
before the script executes. Init blocks are used to define images and
characters, to set up unchanging game data structures, and to
customize Ren'Py. Code inside init blocks should not interact with the
user or change any of the layers, and so should not contain say, menu,
scene, show, or hide statements, as well as calls to any function that
can do these things.

<pre>
init_statement -> "init" (number)? ":"
</pre>

An init statement is introduced with the keyword init, followed by an
optional priority number, and a mandatory colon. If the priority is
not given, it defaults to 0.

The priority number is used to determine when the code inside the init
block executes. Init blocks are executed in priority order from low to
high. Within a file, init blocks with the same priority are run in
order from the top of the file to the bottom. Between files, the order
of evaluation of priority blocks is undefined.

The init blocks are all run once, during a special init phase. When
control reaches the end of an init block during normal execution,
execution of that block ends. If an init statement is encountered
during normal execution, the init block is not run. Instead, control
passes to the next statement.

<h3>Jump Statement</h3>

The call statement is used to transfer control to the statement with
the given name.

<pre>
jump_statement -> "jump" name 
jump_statement -> "jump" "expression" simple_expression 
</pre>

If the <kbd>expression</kbd> keyword is present, the expression is
evaluated, and the string so computed is used as the name of the
statement to jump to. If the <kbd>expression</kbd> keyword is not
present, the name of the statement to jump to must be explicitly
given.

Unlike call, jump does not push the target onto any stack. As a
result, there's no way to return to where you've jumped from.

<example>
label loop_start:

e "Oh no! It looks like we're trapped in an infinite loop."

jump loop_start
</example>

<h3>Label Statement</h3>

Label statements allow a name to be assigned to a program point. They exist solely to be called or jumped to, whether by script code or the Ren'Py library. 

<pre>
label_statement -> "label" name ":"
</pre>

A label statement may have a block associated with it. In that case, control enters the block whenever the label statement is reached, and proceeds with the statement after the label statement whenever the end of the block is reached.

<h3>Menu Statement</h3>

Menus are used to present the user with a list of choices that can be made. In a visual novel, menus are the primary means by which the user can influence the story. 

<pre>
menu_statement -> "menu" ( name )? ":"
</pre>

A menu statement is inroduced by the keyword "menu", an optional name,
and a colon. If the name is supplied it's treated as a label for this
menu statement, as if the menu statement was preceded by a label
statement.

A menu statement must have a block associated with it. This is a
menuitem block that must contain one or more menuitems in it. There
are several kinds of menuitems that can be contained in a menuitem
block.

<pre>
caption_menuitem -> string
</pre>

The first kind of menuitem is a string. This string is placed into a
menu as a caption that cannot be selected. In general, captions are
used to indicate what the menu is for, especially when it is not clear
from the choices.

<pre>
choice_menuitem -> string ( "if" python_expression )? ":"
</pre>

The second kind of menuitem gives a choice the user can make. Each
choice must have a block of Ren'Py statements associated with it. If
the choice is selected by the user, then block of statements
associated with the choice is executed. A choice may also have an
optional <kbd>if</kbd> clause that includes a python expression. This
clause gives a condition that must be satisfied for the choice to be
presented to the user. A terminating colon is used to indicate that
this menuitem is a choice.

<pre>
with_menuitem -> "with" simple_expression
</pre>

The final kind of menuitem is a <kbd>with</kbd> clause. Please see
<ref>Transitions</ref> for more information on with clauses.

<example>
menu what_to_do:

    "What should we do today?"

    "Go to the movies.":
        "We went to the movies."

    "Go shopping.":
        "We went shopping, and the girls bought swimsuits."
        $ have_swimsuits = True

    "Go to the beach." if have_swimsuits:
        "We went to the beach together. I got to see the girls in their
         new swimsuits."
</example>

<b>Details.</b> When a menu is to be shown to the user, the first thing
that happens is that a list of captions and choices is built up from
the menuitems associated with the menu. Each of the choices that has
an expression associated with it has that expression evaluated, and if
not true, that choice is removed from the list.  If no choices survive
this process, the menu is not displayed and execution continues with
the next statement. Otherwise, the <kbd>menu</kbd> function is called
with the list of choices, displays the menu to the user, and returns a
chosen choice. Execution continues with the block corresponding to the
chosen choice. If execution reaches the end of that block, it
continues with the the statement after the menu.

<h3>Pass Statement</h3>

The pass statement does not perform an action. It exists because
blocks of Ren'Py statements require at least one statement in them,
and it's not always sensible to perform an action in those blocks.

<pre>
pass_statement -> "pass"
</pre>

<example>
menu:
    "Should I go to the movies?"

    "Yes":
        call go_see_movie

    "No":
        pass

"Now it's getting close to dinner time, and I'm starving."
</example>

<h3>Python Statement</h3>

The python statement allows one to execute python code in a Ren'Py
script. This allows one to use python code to declare things to
Ren'Py, to invoke much of Ren'Py's functionality, and to store data in
variables that can be accessed by user code. There are two forms of
the python statement:

<pre>
python_statement -> "$" python_code
python_statement -> "python" ( "hide" )? ":"
</pre>

The first form of a python consists of a dollar sign ($) followed by
python code extending to the end of the line. This form is used to
execute a single python statement.

A second form consists of the keyword <kbd>python</kbd>, optionally the
keyword <kbd>hide</kbd>, and a colon. This is used to execute a block
of python statements, which must be supplied as a block after this
statement. Normally, python statements execute in a script-global
namespace, but if the <kbd>hide</kbd> keyword is given, a new namespace
is created for this block. (The script-global namespace can be
accessed from the block, but not assigned to.)

<example>
$ score += 1

python:
    ui.text("This is text on the screen.")
    ui.saybehavior()
    ui.interact()
</example>

<h3>Return Statement</h3>

The return statement pops the top location off of the call stack, and
transfers control to it. If the call stack is empty, the return
statement performs a full restart of Ren'Py.

<pre>
return_statement -> "return"
</pre>


<h3>Say Statement</h3>

The say statement is used to present text to the user, in the form of
dialogue or thoughts. Since the bulk of the of the content of a script
will be dialogue or thoughts, it's important that the say statement be
as convenient as possible. Because of this, the Say statement is the
only statement that is not delimited with a keyword or other form of
delimiter. Instead, it consists of a string, with an optional
simple_expression before it to designate who is doing the speaking,
and an optional with clause after it used to specify a transition.

<pre>
say_statement -> ( simple_expression )? string ( "with" simple_expression )?
</pre>
 
There are two forms of the say statement, depending on if the spimple
expression is provided. The single-argument form consists of a single
string (with or without the optional with clause). This form causes
the string to be displayed to the user as without any label as to who
is saying it. Conventionally, this is used to indicate pov character
thoughts or narration.

<example>
"I moved to my left, and she moved to her right."

"So we were still blocking each other's path."

"I then moved to my right, and at the same time she moved to her
 left."

"We could be at this all day."
</example>


The two-argument form of the say statement consist of a
simple_expression, a string, and optionally a with clause. This form
of the statement is used to indicate dialogue. The first argument is
expected to be an object (usually a Character or DynamicCharacter
object) that knows how to show dialogue to the user. The string is
then passed to that object, which is responsible for showing it to to
the user.

The simple_expression can also be a string, rather than an
object. Strings are used directly as the name of the character.

<example>
"Girl" "Hi, my name is Eileen."

e "Starting today, I'll be living here."
</example>

<b>Details.</b> The two-argument say statement first evaluates the
supplied simple expression. It then attempts to call that value (the
who value) with the string giving the line of dialogue (the what
string). If it can do so, it's finished, as the object that is called
is responsible for interacting with the user.

If it can't call the value of the expression, then it calls the
<kbd>say</kbd> function with the who value and the what string. The say
function is then responsible for showing the dialogue to the user.

The single-argument form of the expression simply calls the special
function (or object) <kbd>narrator</kbd> with the string to be
shown. This function is responsible for showing the string to the
user.  Character and DynamicCharacter objects are suitable for use as
the <kbd>narrator</kbd>.

The with clause is used to specify a transition, see
<ref>With Statement and Clauses</ref> for details.

<h3>Scene Statement</h3>

The scene statement clears a layer by removing all images from it. It
may then show a supplied image to the user. This makes it appropriate
for changing the background of a scene.

<pre>
scene_statement -> "scene" ("onlayer" name | image_spec )?
</pre>

The scene statement first clears out all images from a layer. The
layer is taken from the image_spec or <kbd>onlayer</kbd> clause, if
present. The "master" layer is used if no other layer is specified.

If an image_spec is present, it is then added to the layer, as with
the show statement.

By default, no background is added to the screen, so we recommend that
every script begin with a scene statement that shows a full-screen
background to the user.

<h3>Show Statement</h3>

The show statement takes an image specifier, and adds the specified
image to the specified layer, with the "master" layer used if no
<kbd>onlayer</kbd> clause is present.

<pre>
show_statement -> "show" image_spec
</pre>

The show statement first finds a displayable to add to the
screen. This is done by looking up the image name in the list of
registered images. It then applies all transformations into the at
list to the displayable. This yields the image to be added to the
layer. The show statement then checks to see if an image beginning
with the same image tag can be found in the layer. If such an image
exists, it is replaces with the new image. Otherwise, the new image is
added to the layer, in a position that makes it closer to the user
than any other image.

<example>
scene living_room
show eileen happy at left

e "I'm feeling happy right now."

show eileen upset at left

e "But sometimes, I can get upset for no good reason."
</example>

<h3>With Statement and Clauses</h3>

The with statement and with clauses are used to show transitions to
the user. These transitions are always from the last screen shown to
the user to the current screen. At the end of a with statement, the
last screen shown to the user is set to the current screen. The last
screen shown to the user can also be updated by say or menu
statements, as well as by python code.

The with statement has the form:

<pre>
with_statement -> "with" simple_expression
</pre>

The simple_expression is expected to evaluate to a transition
function. If it evaluates to the value None, the last screen shown to
the user is updated to the current screen, without performing a
transition. This is useful to remove transient interface items (like a
prior say statement) from partaking in a transition.

For convenience, a number of statements support with clauses. In the
case of the scene, show, and hide statements, the with clause is
equivalent to placing a "with None" statement before the scene, show
or hide statement, and a "with transition" statement after it. For
example, the statement:

<example>
show eileen happy with dissolve
</example>

is equivalent to:

<example>
with None
show eileen happy
with dissolve
</example>

This behavior can lead to undesired side-effects. The code:

<example>
show bg whitehouse with dissolve
show eileen happy with dissolve
</example>

will cause two transitions to occur. To ensure only a single transition occurs, one must write:

<example>
with None
show bg whitehouse
show eileen happy
with dissolve
</example>

With clauses can also be applied to say and menu statements. In this
case, the transition occurs when the dialogue or menu is first shown
to the user.

For pre-defined transition functions that can be used in any script,
see ''TODO''. For functions that return transition functions, see
''TODO''.

<h3>While Statement</h3>

The while statement is used to execute a block of Ren'Py statement
while a condition remains true.

<pre>
while_statement -> "while" python_expression ":"
</pre>

When a while statement is executed, the python expression is
evaluated. If it evaluates to true, control is transferred to the
first statement in the block associated with this while statement. If
false, control is instead sent to the statement following the while
statement.

When control reaches the end of the block associated with the while
statement, it returns to the while statement. This allows the while
statement to check the condition again, and evaluate the block if the
condition remains true.

<example>
while not endgame:

   "It's now morning. Time to get up and seize the day."

    call morning
    call afternoon
    call evening

    "Well, time to call it a night."

"Now it's time to wake up and face the endgame."
</example>


<h2>The Ren'Py Runtime Environment</h2>

<h3>Starting Ren'Py</h3>

<h4>Setting Up Paths</h4>

<b>Game Directory.</b> The first thing Ren'Py does when it is started
is to find the <b>game directory</b>. To do this, it finds a directory
using the following rules:

<ol>
 <li>If a game directory is passed to Ren'Py explicitly using the
 <kbd>--game</kbd> command line option, that directory is used.</li>

 <li>Ren'Py uses the name of the executable (.py or .exe file) that
 was used to start Ren'Py. The executable is stripped of any prefix
 before and including the first underscore, and any extension after
 the first dot. If a directory with the remaining name is found
 underneath the directory containing the executable, that directory is
 used. (For example, if the executable name is "run_moonlight.exe", we
 will check for the existence of the "moonlight" directory.)</li>

 <li>If a directory with the name "game" is found under the directory
 containing the executable, that directory is used.</li>

 <li>If a directory with the name "data" is found under the directory
 containing the executable, that directory is used.</li>

 <li>If no other directory has been found, the directory contaning the
 executable is used as the game directory.</li>
</ol>
 
<b>Presplash Image.</b> Ren'Py next checks to see if the file
"presplash.png" is present in the game directory. If this file is
present, it is shown to the user, in its own window, until just after
the init code has finished running. The size of the window is
determined by the size of the presplash image. Ren'Py attempts to
center this window on the screen, and to show the window without a
title bar.

<b>Searchpath.</b> Ren'Py then sets up the search path to include the
game directory and the directory named 'common' underneath the
directory containing the executable. The searchpath is the path script
and data files are loaded from. This path can be modified by changing
<ref>config.searchpath</ref>, but only after the script has been
loaded.

<b>Default Archives.</b> Ren'Py nexts attempts to add some default
archives files. These are files Ren'Py will search in order to find
script and data files. There are three archive files Ren'Py will add
by default. The first uses the name of the executable used for to
start Ren'Py, stripped of any prefix before and including the first
underscorte, and any extension after the first dot, with ".rpa"
appended to it. The other two files are "game.rpa" and "data.rpa". If
these files exist in a directory in the search path, they are added to
<ref>config.archives</ref>, the list of archives Ren'Py will search for
script and data files.

<h4>Loading Scripts </h4>

Once the paths have been setup, Ren'Py attempts to process all of the
.rpy and .rpyc files that are found in the searchpath and default
archives. The script is contained in these .rpy and .rpyc files, with
a .rpy file containing a textual representation of a part of the
script, and a .rpyc file containing a serialized representation of a
similar part of the script. If a .rpy and .rpyc file exist in the same
directory with the same name (differing only in extension), the newer
of the pair of files is loaded. When a .rpy file is loaded, the
corresponding .rpyc file is written out to disk with the serialized
representation of the file. As parsing a .rpy file is expensive,
producing a .rpyc file can save a significant amount of time. As
there's no place to write the corresponding .rpyc file to, .rpy files
may not be loaded from archives.

Once the script has been loaded, Ren'Py must find or generate bytecode
for all python blocks in the script.  This is first done by loading in
the file bytecode.rpyb, if it exists. It may be loaded from disk, or
from inside one of the default archives. For each python block,
bytecode.rpyb is searched for bytecode generated from that block for
the current version of python. If such bytecode cannot be found, that
block is compiled from the python source contained in the script.  If
any compilation was necessary, a new version of bytecode.rpyb is
written into the game directory. To prevent bytecode compilation from
occuring when a user starts your game, bytecode.rpyb should be shipped
as part of the game.


<h4>Initialization</h4>

After the script has been loaded, Ren'Py can begin executing init
blocks. All init blocks found in the script are run, in an order
subject to the following two rules.

<ol>
<li>Init blocks with a lower priority number are run before init blocks with a higher priority number. (Note that init blocks with no explicitly specified priority are assumed to have a priority of 0.)</li>
<li>Within a file, init blocks of the same priority are run in a top-to-bottom order.</li>
</ol>

Note that we do not specify an ordering of init blocks of the same
priority defined in multiple files.

The Ren'Py statements in init blocks should not try to display images,
or interact with the user, as the display will not yet be initialized,
and such interadction will not work.

<h4>Running Game Code</h4>

After the last init block has finished running, the display is
initialized, and running normal game code can be run. It is at this
time that the presplash is removed, if it has been shown.

The first time normal game code is run, the Ren'Py library calls the
label <kbd>splashscreen</kbd>, if it exists. The code at this label can
be used to show a series of in-game splashscreens to the user when the
game is first loaded. When the code returns, execution proceeds.

The next thing Ren'Py does is to call the label <kbd>main_menu</kbd>,
if it exists. If it exists, the <kbd>main_menu</kbd> label is called in
a new context, and is responsible for showing the main menu to the
user. If the <kbd>main_menu</kbd> label does not exists, control is
transferred to the <kbd>_library_main_menu</kbd> label, which shows the
default main menu.

While this main menu can be customized (see <ref>Customizing Menus</ref>
for details), the default main menu includes an
entry, "Start Game", that causes an out-of-context jump to the label
<kbd>start</kbd>. Therefore, it's conventional for the execution of a
game to start at the label <kbd>start</kbd>, which is expected to be
defined by the writer of the script.

The main menu and game menu execute in a different context from the
main game. (The context is used to determine the current location in
the script for saving and loading purposes, among other things.) 
Because of this, the Ren'Py jump statement cannot be used to jump to a
location in the script from the main menu. Instead, a python statement
should be used to call <ref>renpy.jump_out_of_context</ref>.
Alternatively, executing a return statement in the main menu function
will cause execution of the game proper to begin at the "start"
label. So the following code:

<example>
label main_menu:
    return
</example>

will cause execution to begin immediately, skipping the game menu entirely.


<h3>Saving, Loading, and Rollback</h3>

Ren'Py supports saving a game to disk, loading that game back in from
disk, and rolling back the game to a previous state. As these actions
share infrastructure, we will discuss them all in this section, paying
attention to what is required to support loading of a saved game when
a script changes between saving and loading.

Please note that save-game compatibility is not guaranteed between
releases of Ren'Py, even between older and newer releases of
Ren'Py. It may be necessary to take this into account when releasing a
game with an updated version of Ren'Py.

Saving, Loading, and Rollback can all be seen as operations that
affect the game state. Saving is an operation that persists the game
state out to disk, Loading consists of restoring the game state from
disk, and Rollback reverts the game state to what it was at a previous
point in time. This game state consists of two parts: The user state
consists of variables and objects that have been changed by the user,
while the internal state consists of information used by Ren'Py
directly.

<b>Internal State.</b> Specifically, the internal state of Ren'Py
consists of the following:

<ul>
<li>The name of the currently-executing statement.</li>
<li>The name of each statement on the return stack.</li>
<li>The layers containing images that are shown on the screen.</li>
<li>The music that Ren'Py has been requested to play.</li>
<li>The time the game has been played for.</li>
</ul>

These items are automatically saved, loaded, and rolled back when the
appropriate commands are invoked by the user. You do not need do
anything for this state to be handled, and there is no way to prevent
these things from being saved.

<b>User State.</b> The other kind of state that Ren'Py can save and
restore is user state. User state consists of all variables that have
been changed after the end of the init phase, and all objects
transitively reachable from such variables.

It's important to clarify what it means for a variable to be
changed. In Python and Ren'Py, variables reference objects. A variable
changes when it is updated to reference a new object. A variable does
not change when the object it references changes.

For example, in the following code:

<example>
init:
      $ a = 0
      $ state = object()

$ a = 1
$ b = [ ]
$ state.love_love_points = a + 1
</example>

In this example, the variables <kbd>a</kbd> and <kbd>b</kbd> are changed
by the code outside of the init block (assuming that code executes),
while <kbd>state</kbd> is not changed. In the code outside of the init
block, <kbd>a</kbd> is assigned a different integer object, while
<kbd>b</kbd> is assigned a new empty list. While a field on the object
<kbd>state</kbd> refers to has changed, <kbd>state</kbd> itself still
refers to the same object, and not considered to have changed. (Hence,
<kbd>state</kbd> and its associated object are not considered part of
user state.)

User state is gathered by first finding all variables that have
changed outside of init blocks. Ren'Py then finds all objects
reachable from one of those variables through some combination of
field access, iteration, or iteration over items (as in a
dictionary). This combination of variable and object values comprises
the user state.

It's important to ensure that every object in the user state can be
pickled (serialized) by the python pickle module. Most python
constructs can be pickled, including booleans, integers,
floating-point numbers, strings, lists, tuples, dictionaries, and most
objects. You can also refer to your own classes and functions,
provided that they are defined in a python block (not a python hide
block) inside an init block, and always exist with the same name in
later versions of the script. There are some python objects that
cannot be pickled, such as files, iterators, and generators. These
objects should not be used outside of python hide blocks.

While these rules may seem to be complex, it's hoped that in practice
they can be reduced to a simple heuristic: Any variable changed
outside of an init block, and any object reachable from such a
variable, will be saved, loaded, and rolled back properly.

<b>State that isn't Saved.</b> There is some state kept by Ren'Py that
is not part of the interpreter state. This includes:

<ul>
<li>Mappings of image names to displayables, created by the image statement.</li>
<li>Configuration variables (config.varname).</li>
<li>Library variables (library.varname).</li>
<li>Styles (style.stylename).</li>
</ul>

As a result, config variables, library variables, and styles should be
set up in init blocks, and then left alone for the rest of the
game. As the image statement can only be run from inside an init
block, it is impossible to set up a mapping from image name to
displayable outside of an image block. To ensure compatability between
script version, once an image name or style is present in a released
version of the game, it should be present in all future released
versions of the game.


<b>Details.</b> As the game is played, Ren'Py logs all changes to user
and interpreter state. When the game is saved, it writes this log out
to disk, alongside the current state. When the game is loaded back in,
the variables are reset to what the were when the init code in the
current version of the script finished running. The saved user state
is then merged with this, with saved user state overriding any
variable that was also assigned in the init code. Finally, a rollback
is triggered.

The rollback that is triggered on load ends when it can find a
statement that has the same name as it had when it was encountered in
the log. When the script hasn't changed, all statements have the same
name, so the effect of the rollback is to bring control back to the
start of the statement that was executing when the user saved. When
the script has changed, however, the only statements that retain their
names are statements that have an explicit name specified. (These
statements are labels, menu statements with an explicit name, and call
... from ... statements.) The game will rollback to the start of the
most recent statement that exists in both the old and new games.

When a rollback occurs, both user and interpreter state are restored
to what they were when the statement that is being rolled back to
began executing. The statement is then executed again, and play
continues normally.

Please note that we can only roll back the current statement, and not
the return sites listed on the return stack. If the name of a return
site changes, we will not be able to return from a procedure call, and
the script will crash. If a return site has an explicit name, however,
that name is returned to even if the script change. Because of this,
it's important that every call site in a released game have a from
clause associated with it, giving a name for the return site that can
appear in both old scripts.

Finally, if allowed, rollback can be invoked explicitly by the
user. When such a rollback occurs, we first look for a previous
statement that is a checkpoint (checkpoints are say and menu
statements, as well as python blocks that called
<rel>renpy.checkpoint</rel>. Once a checkpoint is found, we look for a
statement which has a name that exists in the current script (this is
normally the same statement). We then rollback to that statement and
begin executing again.

What this means is that when a rollback occurs, the game is usually
reverted to the start of the say or menu statement that executed
before the currently executing statement.

There is one variable that controls the behavior of loading and saving:

<var name="save_name" value ="''">
This is a name that will be associated with save files. It's expected
that the game will update this on a regular basis with the name of the
section of the script that is currently executing. When a save file is
shown to the user, this name will be shown with it. Alternatively,
never change this and no save name will be shown.
</var>

There is one label associated with loading:

<label name="after_load">

If the <kbd>after_load</kbd> label exists, then it is called after a
load has occured. It is responsible for updating variables that may
have changed between script versions, and performing any other action
that may need to be taken in response to the load. When a return
statement is executed, execution is transferred to the point where the
game was saved.

Please note that when calling <kbd>after_load</kbd>, the return stack
is not safe, and hence the user should not be allowed to save before
control returns from <kbd>after_load</kbd>. To be safe, this means the
<kbd>after_load</kbd> code should not be interactive.

</label>

<h4>Persistent Data</h4>

Ren'Py als supports persistent data, which is saved data that is not
associated with a single game. Persistent data is data that is
accessed through the fields of the persistent object, which is bound
to the variable <kbd>persistent</kbd>.

<var name="persistent" value="...">
The persistent variable is bound to the special persistent object. All
data reachable through fields on persistent is saved whenver Ren'Py
terminates, and loaded when Ren'Py resumes. The persistent object is
special in that an access to an undefined field on it will have a
<kbd>None</kbd> value, rather than causing an exception.
</var>

An example use of persistent is the creation of an unlockable image
gallery. This is done by storing a flag in persistent that determines
if the gallery has been unlocked, as in:

<example>
label gallery:

    if not persistent.gallery_unlocked:
        show background
        centered "You haven't unlocked this gallery yet."
        $ renpy.full_restart()

    # Actually show the gallery here.
</example>

When the user gets an ending that causes the gallery to be unlocked,
the flag must be set to True:

<example>
$ persistent.gallery_unlocked = True
</example>

Please note that a more sophisticated image gallery ships in the
extras/ directory with Ren'Py.

<h3>Defining Characters</h3>

When showing dialogue to the user using the two-argument form of the
say statement, the first argument to the say statement should almost
always be a variable bound to a Character object. These objects
implement (or call functions that implement) much of the logic
required to show dialogue to the user.

Characters are declared by binding variables to the Character
objects. Such declarations should take place inside init blocks, to
ensure that the bindings are not saved with the game state, as this
would prevent revised versions of a game from picking up changes to
the init block. Perhaps the simplest definition is:

<example>
init:
    $ e = Character("Eileen")
</example>

This creates a new character object and binds it to the <kbd>e</kbd>
variable. When the say statement:

<example>
e "Hello, World!"
</example>

runs, the line of text "Hello, World!" will be preceded by the label
"Eileen", indicating who is talking. It's common to customize the
color of this label. This can be done by supplying the <kbd>color</kbd>
keyword argument to Character, as in:

<example>
init:
    $ e = Character("Eileen", color=(200, 255, 200, 255))
</example>

The color argument is actually setting the 
<a href="#property:color">color</a> property on the label. The color
property takes an RGBA tuple consisting of four numbers, enclosed in
parenthesis and separated by commas, with each number ranging from 0
to 255.

The <kbd>Character</kbd> function is defined as follows:

<func name="Character" sig="(name, **kwargs)">

Creates a new character object. This object is suitable for use as the
first argument of a two-argument say statement. When it is used as
such, it shows a window containing the character name and the second
argument to the say statement. This behavior is customized by passing
parameters to this function.

<i>name</i> is the name of the character that is speaking. It can be
either a string containing the character name, or None to indicate
that the label should not be shown. The empty string <kbd>""</kbd>
indicates that the label should be blank line, which allows a
<kbd>narrator</kbd> character to line up narration with character
dialogue. <i>name</i> is the only requirement to Character.

<b>Keyword Arguments.</b> In addition to <i>name</i>,
<kbd>Character</kbd> takes keyword arguments that control its
behavior.

<i>dynamic</i> - If true, then <i>name</i> is interpreted as a string
containing a python expression that is evaluated to yield the name of
the character.

<i>image</i> - If true, then <i>name</i> is interpreted as an
image. This image is added to the dialogue window in place of the
label.

<i>condition</i> - If present, this should be a string containing a
python expression. This expression is evaluated whenever a line is
said through this character object. If it evaluates to false, the line
is not shown to the user.

<i>interact</i> - If true, the default, causes an interaction to occur
when a line is shown to the user. If false, the interaction does not
take place, and <ref>ui.interact</ref> (or some other means) must be
called to cause an interaction to occur.

<b>Prefixes and Suffixes.</b> The following keyword arguments can be
used to add a prefix or suffix to everything said through a character
object. These can be used when lines of dialogue need to be enclosed
in quotes, as the preferred alternative to adding those quotes to
every line of dialogue in the script.

<i>who_prefix</i> - Text that is prepended to the name of the character
when forming the label of the dialogue.

<i>who_suffix</i> - Text that is appended to the name of the character
when forming the label of the dialogue.

<i>what_prefix</i> - Text that is prepended to the line of dialogue
before it is shown to the user.

<i>what_suffix</i> - Thext that is appended to the line of dialogue
before it is shown to the user.

<b>Click-to-continue.</b> These keyword arguements are used to control
the click-to-continue indicator:

<i>ctc</i> - If present, this argument takes a displayable that is used
as the click-to-continue indicator. If not present or None, then no
click-to-continue indicator is displayed.

<i>ctc_position</i> - If "nestled", the click-to-continue indicator is
displayed nestled in with the end of the text. If "fixed", the
click-to-continue indicator is displayed directly on the screen, with
its various position properties determining where it is actually
shown.

<b>Functions.</b> The following are keyword that allow one to
massively customize the behavior of a character object:

<i>show_function</i> - The function that is called to display each step
of a dialogue to the user. (A dialogue may be broken down into steps
by pause text tags.) It should have the same signature as
<rel>renpy.show_display_say</rel>.

<i>predict_function</i> - The function that is called to predict the
images from this dialogue. It should have the signature of
<rel>renpy.predict_display_say</rel>.

<b>Styles.</b> The following keyword arguments control the styles used
by parts of the dialogue:

<i>who_style</i> - Defaults to 'say_label', the style of the label.

<i>what_style</i> - Defaults to 'say_dialogue', the style of the text
being said.

<i>window_style</i> - Defaults to 'say_window', the style of the window
containing the dialogue.


<b>Additional Keyword Arguments.</b> Additional keyword arguments are
interpreted as follows:

<ul>
<li> Keyword arguments beginning with "window_" are intepreted as
properties of the window containing the dialogue, with the
window_" prefix stripped off.</li>
 
<li>Keyword arguments beginning with "what_" are interpreted as
properties of the text being said, with the "what_" prefix stripped
off.</li>

<li>Keyword arguments begining with "show_" are supplied as keyword
arguments to the <i>show_function</i> and <i>predict_function</i>, with
the "show_" prefix stripped off.</li>

<li>All other keyword arguments are interpreted as properties of the
label.</li>
</ul>

</func>

There is also a <kbd>DynamicCharacter</kbd> function:

<func name="DynamicCharacter" sig="(name, **kwargs)">
Equivalent to calling  <ref>Character</ref> with the same arguments, and
with the <i>dynamic</i> argument set to true.
</func>

<b>Calling Character Objects.</b>
Character objects may be called directly, as if they were
functions. They take one positional parameter, the line of dialogue to
be show to the user. They also take one keyword parameter,
<i>interact</i>, which determines if an interaction should take
place. This use can programatically replace say statements. For
example, the say statement:

<example>
e "Hello, World!"
</example>

is equivalent to:

<example>
$ e("Hello, World!")
</example>


<h3>Text</h3>

This section covers aspects of text in Ren'Py. It first covers
interpolation, supported by the say and menu statements, which allows
values to be substituted into text. It next discusses text tags, which
allow the style of portions of strings of text to be
customized. Finally, it covers how Ren'Py handles fonts.

<h4>Interpolation</h4>

Interpolation is supported by the say and menu statements. These
statements support python string interpolation over the contents of
the store. The strings used by the statements support conversion
specifiers of the form <kbd>%(variable)s</kbd>, where
<kbd>variable</kbd> is the name of a variable and <kbd>s</kbd> is a
conversion. Useful conversions include 's', which interpolates a
string; 'd', which interpolates an integer; and 'f', which
interpolates a floating point number. Conversions may also include
characters that modify how the string is converted. More information
about conversions can be found at <a href="http://www.python.org/doc/2.3.5/lib/typesseq-strings.html">http://www.python.org/doc/2.3.5/lib/typesseq-strings.html</a>.

In strings where interpolation is supported, percent characters (%)
must be duplicated (to %%) to prevent them from being interpreted as
introducing interpolation.

<example>
$ name = 'Samantha'
$ age = 19
$ withyou = 110

girl "My name is %(name)s, and I am %(age)d years old. I'm with you %(withyou)d%%"
</example>

When interpolation is not supported, the effect can often be faked by
formatting a string against the result of calling the globals()
function.

<example>
ui.text("%(name)s's Vital Statistics" % globals())
</example>

Text tag processing is performed after interpolation, so it's
important to ensure interpolation does not introduce text tags.

<h4>Text Tags</h4>

Text displayed by Ren'Py supports text tags. While styles can only be
applied to an entire Text displayable, allow only a portion of the
text in the displayable to be customized. As text tags are part of the
Text displayable, they may be used in any string that is displayed on
the screen. However, some of the text tags will only have effect if
used in the appopriate context.

Text tags should be used fairly sparingly. If you find you're using
text tags on every line of the game, it's quite possible text tags are
not the right solution for the problem at hand. Investigate text
styles as a possible alternative to text tags.

Text tags start with a left brace ({}, and continue to the matching
right brace (}). Immediately following the left brace is the tag
name. The name may be followed by an argument, which is separated from
the tag name by an equals sign (=). Some tags require an argument,
while others require that the argument be omitted. Text tags are
sensitive to case and white space.

Some tags require a corresponding closing tag. A closing tag is any
text tag where the name begins with a slash (/). Closing tags should
be properly nested: "{b}{i}this is okay{/i}{/b}", while "{b}{i}this is
wrong{/b}{/i}". While improper nesting of text tags will generally not
cause an error, this problem may cause undesirable rendering
results. The text between a tag and the corresponding closing tag is
called the enclosed text. All tags must be closed by the end of the
text string.

To include a single left brace in text, two left braces ({{) musty be
included instead.

Ren'Py supports the following text tags:

<ul>
<li>{a=''argument''} and {/a} cause their enclosed text to be rendered as a hyperlink. The enclosed text may contain text tags, but may not contain another hyperlink. A hyperlink is rendered as a button containing the enclosed text. The text in the button does not participate in line-breaking. Rather, if the text grows too big for the line it is on, the whole button is moved to the start of the next line.</li>
</ul>

 When a a hyperlink is clicked, the config.hyperlink_callback function is called with the text of the argument of the hyperlink. The default hyperlink handler interprets argument as a label, and calls this label in a new context. This is an appropriate behavior when using hyperlinks to definitions of unfamiliar terms. Hyperlinks should not be used as a general control-flow tool, as they transfer control to a new context when clicked. If the user saves while inside that context, when he loads the game he will be returned to the screen containing the hyperlink. 

<example>
init:
    $ definition = Character(None, window_yfill=True, window_xmargin=20, 
                             window_ymargin=20, window_background=Solid((0, 0, 0, 192)))

label start:

    "A game that instructs on how to make a game? Isn't that a sort of {a=define_quine}Quine{/a}?"

    # ...

label define_quine:

    definition "Quine:\n\nA program that prints itself to its output."

    return
</example>

<ul>
<li>{b}text{/b} renders the enclosed text in a bold font.</li>
<li>{color=spec}text{/color} changes the color of the enclosed text. The
color may be a hex triple or a hex sextuple, optionally preceded by a
hash mark. (The same format that color() accepts. f00, ff0000, #f00,
and #ff0000 are all valid representations of red.)</li>
<li>{fast} causes the immediated display of text before it. It can be
used to specify where slow text shold begin to display from. It only
has an effect if the text speed preference is not infinite.  Use this
if you have two lines of dialogue where the second is an extension of
the first, as a variant of the pause effect that allows for changes to
occur while paused. This tag does not take a closing tag.</li>
<li>{i}text{/i} makes the enclosed text in an italic font.</li>
<li>{image=filename} causes the supplied image to be loaded and
included into text. The image should are treated as if they were text,
and should not be taller than a single line of text. {image} does not
take a closing tag.</li>
<li>{p} causes the display of text to be paused until the user clicks
to continue, or until an auto-forward occurs. This allows text to be
displayed incrementally. {p} does not take a closing tags, and causes
a newline to be interted after the given text. The logic to handle
pausing is implemented in the Character object, and may not work for
other text widgets.</li>
<li>{plain}text{/plain} makes the enclosed text plain, eliminating
bold, italic, and underline styles</li>
<li>{size=spec}text{/size}
changes the size of the text. The supplied spec may be a number, in
which case it is the number of pixels high that the text will be. If
it is a number preceded by a plus (like "+10"), it means to increase
the size by that number of pixels, while if it is preceded by a minus
it means to decrease.</li>
<li>{u}text{/u} renders the enclosed text with
an underline. </li>
<li>{w} is similar to {p}, except that it does not
cause a newline.</li>
</ul>

The following is an example of a say statement that uses many text
tags. Use of this many text tags is not recommended in a high-quality
game.

<example>
"Using text tags, we can make text {size=+12}bigger{/size} or
 {size=-8}smaller{/size}. We can make it {b}bold{/b}, {i}italic{/i},
 or {u}underlined{/u}. We can even change its {color=#f88}color{/color}."
</example>

<h4>Fonts and SFonts</h4>

The Text displayable attempts to find an an appropriate font using
information about the font name, boldness, italics, underline and
size. This information is supplied to the Text displayable using style
properties, but may then be modified using text tags. Ren'Py
translates this into a font using the following algorithm.

<ul>
<li>A (name, boldness, italics) triple is looked up in
<ref>config.font_replacement_map</ref>. If present, it is expected to
map to triple giving replacemen values for name, boldness, and
italics. This lookup is not recursive, so only one lookup is
performed. This lookup allows specific bold or italic font shapes to
be used.</li>
<li>If a SFont has been registered with the same name, size, boldness,
italics, and underline, that SFont is used.</li>
<li>Otherwise, Ren'Py interprets the font name as the filename of a
truetype font. This filename is searched for in the searchpath and
archives. If found, it is used as the font file.</li>
<li>Otherwise, Ren'Py searches for a font with the given filename in
the system font directory. If found, that file is used.</li>
<li>Otherwise, Ren'Py interprets the filename as the name of a
truetype font, which is loaded if found.</li>
</ul>

The truetype font loading code will automatically scale, bold,
italicize, and underline the font as required.

For best results, fonts should be truetype files that ship with the
game. This ensures that required fonts are always present on the
user's system.

<b>SFonts.</b> Ren'Py supports rendering text using SFonts as well as
TrueType fonts. An SFont is a properly prepared image file, usually a
PNG, containing images of the character in the font. Ren'Py has its
own implementation of SFonts that supports an arbitrary unicode
character set and kerning.

SFonts have several advantages and several disadvantages. One of the
advantages is that SFonts are bitmap-based. This allows them to be
distributed without having to worry about the copyrights associated
with TrueType fonts. Also, as SFonts are images, it's possible to
apply effects to them that Ren'Py would not otherwise support. The
downsides of SFonts come from the fact that Ren'Py doesn't render
them, but instead merely copies characters out of them. Because of
this, one needs to supply another image to Ren'Py if one wants the
font to be scaled, made bold, made italic, or underlined. Ren'Py will
recolor the SFont, with white being mapped to the supplied color, and
other colors interpolated on a channel-by-channel basis.

For more information about SFonts, see http://www.linux-games.com/sfont/.

To use SFonts, they must first be registered with Ren'Py using the
renpy.register_sfont function. They can then be used by setting the
font property of a style to the name of the SFont.

<!-- func renpy.register_sfont -->


The default character set for a SFont is:

<pre>
! " # $ % &amp; ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; &lt; = > ? 
@ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ 
` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~
</pre>

Please note that you must register a sfont for each combination of
font, size, bold, italic, and underline your game uses.


<h3>Displayables</h3>

A <b>displayable</b> is a python object implementing an interface that
allows it to be displayed to the screen. Displayables can be assigned
to an image name using an <ref>Image Statement</ref>, and can then be
shown to the user using the show and hide statements. They can be
supplied as an argument to the <ref>ui.add</ref> function. They are
also used as the argument to certain style properties. In this
section, we will describe functions that create displayabls.


<h4>Image Manipulators</h4>

An Image is a type of displayable that contains bitmap data that can
be shown to the screen. All images are displayables, but not all
displayables are images. Images differ from displayables in that they
can be statically computed, and stored in the image cache. This
loading occurs sometime before the image is to be used (but not at the
time the Image is created). This generally makes Images faster than
arbitrary displayables. An image manipulator is a function that
returns an Image.

An image manipulator may take an Image as an argument. An Image can be
supplied to an image manipulator in two ways:

<ul>
<li>It may be supplied directy, by using the result of one image
manipulator as the argument to another.</li>
<li>It may be supplied as a string. In this case, the string is
interpreted as a filename, that is loaded with <ref>im.Image</ref>.</li>
</ul>

The image manipulators are:

<!-- func im.Image-->

<func name="Image" sig="(...)">
An alias for <kwd>im.Image</kwd>.
</func>

<!-- func im.Alpha -->

<!-- func im.Composite -->

<!-- func im.Crop -->

<!-- func im.Flip -->

<!-- func im.Map -->

<!-- func im.ramp -->

<!-- func im.Scale -->

<!-- func im.Recolor -->

<!-- func im.Rotozoom -->

<!-- func im.Tile -->

<h4>Backgrounds</h4>

There are two displayables that are eminently suitable for use as
backgrounds:

<!-- func Frame-->

<!-- func Solid-->

<h4>Dynamic</h4>

DynamicDisplayable can be used in styles to change the displayable
shown over the course of the game.

<!-- func DynamicDisplayable -->

One use of this is to change the background of (say) the game menu
screen over the course of the game. For example:

<example>
init:
     $ gm_background = "gmbg1.png"
     $ style.gm_root.background = DynamicDisplayable("Image(gm_background)")

label start:

     "Here, we'll show the game menu with background 1."

     $ gm_background = "gmbg2.png"

     "Now, we're showing it with background 2."
</example>

<h4>Animations</h4>

Ren'Py provides several kinds of animation displayables.

These animation functions take an <i>anim_timebase</i> parameter,
that determines which timebase to use. The animation timebase, used
when anim_timebase is True, starts at the instant of the first frame
from which the tag of the image containing this animation has been
shown on the screen. This can be used to switch between two
animations, in a way that ensures they are synchronized to the same
timebase. The displayable timebase, used when anim_timebase=False,
starts at the first frame after the displayable is shown, and can be
used to ensure the entire animation is seen, even if an image with the
same tag was already on the screen.

The animation functions are:

<!-- func Animation-->

<example>
init:
    image animation = Animation("frame_1.png", 0.25,
                                "frame_2.png", 0.25,
                                "frame_3.png", 0.25)
</example>

<!-- func anim.Blink-->

<!-- func anim.Filmstrip-->

<!-- func anim.SMAnimation-->

<!-- func anim.State-->

<!-- func anim.Edge-->


We present two examples of this in action. The first shows how one can
create a character that ocassionally, randomly, performs a 3-frame
blink about once a minute.


<example>
init:
    image blinking = anim.SMAnimation("a",
        anim.State("a", "eyes_open.png"),

        # This edge keeps us showing the eyes open for a second.
        anim.Edge("a", 1.0, "a", prob=60),

        # This edge causes the eyes to start closing...
        anim.Edge("a", 0.25, "b"),

        # ..because it brings us here.
        anim.State("b", "eyes_half.png"),

        # And so on...
        anim.Edge("b", 0.25, "c"),
        anim.State("c", "eyes_closed.png"),
        anim.Edge("c", 0.25, "d"),
        anim.State("d", "eyes_half.png"),

        # And back to a.
        anim.Edge("d", 0.5, "a")
        )
</example>


Remember, State can take a Position, and Edge can take a
transition. This lets you move things around the screen, dissolve
images into others, and do all sorts of complicated, unexpected,
things. (But be careful... not all transitions do what you'd expect
when used with SMAnimation.)


<h4>Layout</h4>

These displayables are used to layout multiple displayables at once.

<!-- func LiveComposite-->

<!-- func Fixed-->

<!-- func HBox-->

<!-- func VBox-->


<h4>Particle Motion</h4>

Ren'Py supports particle motion. Particle motion is the motion of
many particles on the screen at once, with particles having a lifespan
that is shorter than a single interaction. Particle motion can be used
to have multiple things moving on the screen at once, such as snow,
cherry blossoms, bubbles, fireflies, and more. There are two
interfaces we've provided for the particle motion engine. The
SnowBlossom function is a convenience constructor for the most common
cases of linearly falling or rising particles, while the Particles
function gives complete control over the particle engine.

SnowBlossom is a function that can be used for the common case of
linearly rising or falling particles. Some cases in which it can be
used are for falling snow, falling cherry blossoms, and rising
bubbles.

<!-- func SnowBlossom-->

The result of SnowBlossom is best used to define an image, which can
then be shown to the user.

<example>
init:
    image blossoms = SnowBlossom(Animation("sakura1.png", 0.15,
                                           "sakura2.png", 0.15))
</example>

It may make sense to show multiple snowblossoms at once. For example,
in a scene with falling cherry blossoms, one can have small cherry
blossoms falling slowly behind a character, while having larger cherry
blossoms falling faster in front of her.

If SnowBlossom does not do what you want, it may make sense to define
your own particle motion. This is done by calling the Particles
function.

<!-- func Particles-->

The particles function expects to take as an argument a factory
object. This object (which should be pickleable) must support two
methods.

The <kwd>create</kwd> method of the factory object is called once per frame
with two arguments. The first is either a list of existing particles,
or None if this is the first time this Particles is shown (and hence
there are no particles on the screen). The second argument is the time
in seconds from some arbitrary point, increasing each time create is
called. The method is expected to return a list of new particles
created for this frame, or an empty list if no particles are to be
created this frame.


The <kwd>predict</kwd> method of the factory object is called when image
prediction is requested for the Particles. It is expected to return a
list of displayables and/or image filenames that will be used.

Particles are represented by the objects returned from each factory
function. Each particle object must have an <kwd>update</kwd> method. This method
is called once per frame per particle, usually with the time from the
same arbitrary point as was used to create the object. (The arbitrary
point may change when hidden and shown, so particle code should be
prepared to deal with this.) The <kwd>update</kwd> method may return None to 
indicate that the particle is dead. Nothing is shown for a dead
particle, and update is never called on it. The <kwd>update</kwd> method can
also return an (xpos, ypos, time, displayable) tuple. The xpos and ypos
parameters are a position on the screen to show the particle at,
interpreted in the same way as the xpos and ypos style properties. The
time is the time of display. This should start with the time
parameter, but it may make sense to offset it to make multiple
particle animations out of phase. Finally, the displayable is a
displayable or image filename that is shown as the particle.

# END NOPAR


<h4>Position and Motion Functions</h4>

<function name="Position" sig="(**properties)">

<p>
Position, when given position properties as arguments, returns a
callable that can be passed to the "at" clause of a show or
scene statement to display the image at the given location. See
the section below on position properties to get a full
explanation of how they are used to lay things out, but
hopefully this example will show how Position can be used:
</p>
</function>

<example>
init:
    left = Position(xpos=0.0, xanchor='left')
    center = Position(xpos=0.5, xanchor='center')
    right = Position(xpos=1.0, xanchor='right')

    top = Position(xpos=0.5, xanchor='center', ypos=0.0,
                   yanchor='top')

show eileen happy at left
</example>

<function name="Motion" sig="(function, period, repeat=False, bounce=False, **properties)">

<p>
Motion, when given the appropriate arguments, returns an object that
when given as the at clause of an image causes an image to be moved on
the screen. Function is a function that, when given a number between 0
and 1, returns two or four values. The first two values are
interpreted as the xpos and the ypos of the motion. (Please note that
if these values are floating point numbers, they are interpreted as a
fraction of the screen. If they are integers, they are interpreted as
the absolute position of the anchor of the motion.) If four values are
returned, the third and fourth values are interpreted as an xanchor
and yanchor.
</p>

<p>
Please note that the function may be pickeled, which means that it
cannot be an inner function or a lambda, but must be a function
defined in an init block of your script. In general, it's better to
use a Pan or a Move, rather than defining your own motion.
</p>

<p>
Period is the time, in seconds, it takes to complete one cycle of
a motion. If repeat is True, then the cycle repeats when it finishes,
if False, the motion stops after one period. If bounce is True, the
argument to the function goes from 0 to 1 to 0 in a single period, if
False, it goes from 0 to 1.
</p>

</function>

<function name="Pan" sig="(startpos, endpos, time, repeat=False, bounce=False, **properties)">

<p>

Pan, when given the appropriate arguments, gives an object that
can be passed to the at clause of an image to cause the image to
be panned on the screen. The parameters startpos and endpos are
tuples, containing the x and y coordinates of the upper-left hand
corner of the screen relative to the image. Time is the time it
will take this position to move from startpos to endpos. Repeat
and bounce are as for Motion.

</p><p>

As the current implementation of Ren'Py is quite limited, there
are quite a few restrictions that we put on pan. The big one is
that there always must be a screen's worth of pixels to the
right and below the start and end positions. Failure to ensure
this may lead to inconsistent rendering.

</p><p>

Hopefully, an example will demonstrate how Pan is used. For this
example, assume that the screen is 800 x 600, and that the
image marspan is 2400 x 600 pixels in size. We want to take 10
seconds to pan from left to right on the image.

</p>

<example>
scene marspan at Pan((0, 0), (1600, 0), 10.0)
</example>

<p>
Please note that the pan will be immediately displayed, and that
Ren'Py will not wait for it to complete before moving on to
the next statement. This may lead to the pan being overlayed
with text or dialogue. You may want to use a call to renpy.pause
to delay for the time it will take to complete the pan.
</p>

<p>
Finally, also note that when a pan is completed, the image locks
into the ending position.
</p>

</function>

<function name="Move" sig="(startpos, endpos, time, repeat=False, bounce=False, **properties)">

<p>
Move is similar to Pan, insofar as it involves moving
things. But where Pan moves the screen through an image, Move
moves an image on the screen. Specifially, move changes the
position style of an image with time.
</p>

<p>
Move takes as parameters a starting position, an ending
position, the amount of time it takes to move from the starting
position to the ending position, and extra position
properties. The positions are given as tuples containing xpos
and ypos properties. The positions may be integer or floating
point, but it's not permissable to mix the two. Repeat and
bounce are as for Motion.

</p>

<p>
The following example moves a ball from the upper-left to the
lower-right of the screen, taking 10 seconds to do so.
</p>

<example>
show ball at Move((0.0, 0.0), (1.0, 1.0), 10.0,
                  xanchor="center", yanchor="center")
</example>

</function>

<p>
In general, one wants to use Pan when an image is bigger than the
screen, and Move when it is smaller. Both Pan and Move are special
cases of Motion.
</p>

<p>
anim.SMAnimation can also be used to declare complicated motions. Use
None instead of an image in States, and supply a move transition
when moving between states. A SMAnimation so created can be passed in
to the at clause of an image, allowing it to move things around the
screen.
</p>

<p>
These movement clauses can also be used as transitions, in which case
they affect the position of a single layer or the entire screen, as
appropriate.
</p>

<function name="Zoom" sig="(size, start, end, time, after_child=None, **properties)">

<p>
    This displayable causes a zoom to take place, using image
    scaling. The render of this displayable is always of the supplied
    size. The child displayable is rendered, and a rectangle is
    cropped out of it. This rectangle is interpolated between the
    start and end rectangles. The rectangle is then scaled to the
    supplied size. The zoom will take time seconds, after which it
    will show the end rectangle, unless an after_child is
    given.
</p><p>
    The algorithm used for scaling does not perform any
    interpolation or other smoothing.
</p>

<p>
        <span class="param">size</span> - The size that the rectangle is scaled to, a
        (width, height) tuple.
</p><p>
        <span class="param">start</span> - The start rectangle, an (xoffset, yoffset,
        width, height) tuple.
</p><p>
        <span class="param">end</span> - The end rectangle, an (xoffset, yoffset,
        width, height) tuple.
</p><p>
        <span class="param">time</span> - The amount of time it will take to
        interpolate from the start to the end rectange.
</p><p>
        <span class="param">after_child</span> - If present, a second child
        widget. This displayable will be rendered after the zoom
        completes. Use this to snap to a sharp displayable after
        the zoom is done.
</p>

</function>




<h3>Transitions</h3>

<p>
By default, Ren'Py displays each scene by replacing the old
scene with a new one. This is appropriate in general (such as
for emotion changes), but it may be boring for large
changes, such as a change in location or a character entering or
leaving the scene. Ren'Py supports transitions that control how
changes to the scene lists are exposed to the user.
</p>

<p>
Transitions occur between the last scene that was shown to
the user, and the current scene that has been updated using
the scene, show, or hide statements. A transition takes both lists
as input, and is responsible for displaying the transition between
them to the user. Each transition runs for a given amount of time,
but may be dismissed early by the user. Once a transition is
shown, the scene is considered shown for the purposes of
future transitions.
</p>

<rule>with_statement -> "with" simple_expression</rule>

<p>
Transitions are introduced with the with statement. The with
statement takes an expression that is suitable for use with the
with statement (that is, a callable that takes as input two scene
lists), and runs that transition. Alternatively, if the expression
is None, then the with statement has the effect of showing the
scene to the user, and returning instantly. This is useful in
conjunction with a future with statement, so that only some
changes to the scene list will be transitioned in.
</p>

<p>
An example is in order. First, let us define a few objects that
can be passed in as the argument to a with statement:
</p>

<example>
init:
    # Fades to black, then to the new scene.
    fade = Fade(0.5, 0, 0.5)

    # Dissolves between old and new scenes.
    dissolve = Dissolve(0.5)
</example>

<p>
A simple use of with would be to place it after a series of show
and hide statements of the program. As an example:
</p>

<example>
scene bg whitehouse
show eileen happy
with fade
</example>

<p>
This series of statements will cause the old scene (displayed
before these statements started) to fade to black, and be replaced
with the new scene all at once. This is a useful behavior, for
example, when we are replacing a scene with a new one, such as
when the story changes locations.
</p>

<example>
scene bg whitehouse
with None
show eileen happy
with dissolve
</example>

<p>
The "with None" statement is useful to break changes to the scene
list into parts, as in the example above. When run, the background
will be instantly shown, and then the character image will be
dissolved in over the background.
</p>

<p>
Another use of the "with None" statement is to remove transient
elements before a transition begins. By default, the scene list
includes transient elements like dialogue, thoughts, and
menus. "with None" always executes without these elements, and so
gets rid of them.
</p>

<p>
The "show", "hide", and "scene" statements all take a with
clause. One of these statement with a with clause associated with
it is actually converted into three statements: A "with None"
statement, the original statement sans the with clause, and the
with clause as a with statement. For example:
</p>

<example>
scene bg whitehouse with fade
show eileen happy at left with dissolve
show lucy happy at right with dissolve
</example>

<p>
becomes
</p>

<example>
with None
scene bg whitehouse
with fade
with None
show eileen happy at left
with dissolve
with None
show lucy happy at right
with dissolve
</example>

<p>
This has the effect of fading out the old scene and fading in the
new background, then dissolving in the characters one after the
other.
</p>

<p>
We also allow with clauses to be supplied for say and menu
statements. When a with clause is supplied on one of these
statements, the transition is used to introduce the say or menu
element. For example,
</p>

<example>
e "How are you doing?" with dissolve
</example>

<p>
Will dissolve in a line of dialogue. The line of dialogue will be
dismissed immediately, unless it is followed by a with statement
or clause that causes it to transition to something else.
</p>

<p>
There is one variable that controls transitions:
</p>

<dl>
<var name="default_transition" value="None">
If not none, specifies a default transition that is applied to
all say and menu statements that are not provided a with
clause. This is only considered if the transitions preference is
set to "All".
</var>
</dl>

<p>
The following are functions that return things useful as
transitions. The user should not supply the new_widget or old_widget
parameters, as these are supplied by Ren'Py when a transition
begins.
</p>

<!-- func Fade -->

<!-- func Dissolve -->

<!-- func ImageDissolve -->

<!-- func CropMove -->

<!-- func Pixellate -->

<!-- func MoveTransition -->

<p>
Some transitions can also be applied to specific layers, using the
renpy.transition function (documented below). Only transitions that
are not completely opaque can be used in this way.
</p>


<h3>Interaction Functions</h3>

<p>
The following functions either implement new game behavior that
didn't merit its own statement, or complement the behavior of
statements.
</p>

<example>
init:
    $ e = Character("Eileen", color=(200, 255, 200, 255))

e "My name is shown in full, and in green."
</example>

<!-- func renpy.display_say -->

<!-- func renpy.show_display_say -->

<!-- func renpy.predict_display_say -->

<!-- func renpy.display_menu -->

<!-- func renpy.pause -->

<!-- func renpy.input -->

<example>
$ name = renpy.input("What is your name?", "Joe User", length=20)

e "Pleased to meet you, %(name)s."
</example>

<!-- func renpy.imagemap -->

<example>
    $ result = renpy.imagemap("ground.png", "selected.png", [
        (100, 100, 300, 400, "eileen"),
        (500, 100, 700, 400, "lucy")
        ])


    if result == "eileen":
        e "You picked me!"

    elif result == "lucy":
        e "It looks like you picked Lucy."
</example>

<!-- func renpy.transition -->

<!-- func renpy.checkpoint -->

<!-- func renpy.block_rollback -->

<!-- func renpy.restart_interaction -->

<!-- func renpy.full_restart -->

<!-- func renpy.quit -->

<!-- func renpy.loadable -->

<!-- func renpy.exists -->

<!-- func renpy.clear_game_runtime -->

<!-- func renpy.get_game_runtime -->

<!-- func renpy.choice_for_skipping -->

<!-- func color -->

<p>
Contexts store the current scene lists and execution location. Ren'Py
supports a stack of contexts, but only the top-level context is saved
to the save file.
</p>

<!-- func renpy.context -->

<!-- func renpy.call_in_new_context -->

<!-- func renpy.invoke_in_new_context -->

<!-- func renpy.jump_out_of_context -->

<!-- func renpy.log -->

<!-- func renpy.watch -->

<!-- func renpy.get_filename_line -->

<!-- func renpy.image -->
<!-- func renpy.scene -->
<!-- func renpy.show -->
<!-- func renpy.hide -->

<p>
Finally, there exists an object named renpy.random. This object is
a random number generator that implements the <a
href="http://www.python.org/doc/2.3.4/lib/module-random.html">Python
random number generation interface</a>. However, unlike the
standard random number generator, this object cooperates with
rollback, generating the same numbers regardless of how many times
we rollback. It should be used instead of the standard Python
random module.
</p>

<h3>Overlays</h3>

<p>
Overlays are used to display information above the scene currently
displayed. The overlay is regenerated each time an interaction
with the user begins, making it suitable for displaying to the
user things like statistics or dates. The overlay is generally
displayed whenever transient things (like dialogue, thoughts and
menus) are.
</p>

<p>
Overlays are set up by adding to the config.overlay_functions list
a python function which, when called, uses the ui functions to add
widgets to the screen. By default, such widgets are added to the
'overlay' layer, but a call to ui.layer() can change the layer
to any of the layers listed in library.overlay_layers. These functions are
called for each interaction, which allows the overlay to change to
reflect the status of game variables. If a variable affecting the
overlay changes during an interaction, renpy.restart_interaction()
should be called to regenerate the overlay.
</p>

<p>
As an example, take the following code fragement. When added to a
program, this displays a date image in the upper-right corner of
the screen (as is done in Kanon). The image shown is based on the
variable date. If date is None, then no date is shown. Otherwise,
a png file beginning with the value of date is shown.
</p>

<example>
init:
    $ date = "mar25"

    python hide:
        def date_overlay():
            if date:
                ui.image(date + ".png",
                         xpos=1.0, xanchor="right",
                         ypos=0.0, yanchor="top") ]

        config.overlay_functions.append(date_overlay)
</example>

<p>
Like all config variables, config.overlay_functions should only be
changed in an init block. If you need to toggle an overlay on and
off, then the overlay function should be conditioned on some
normal variable, returning an empty list if it is false. This is
done in the example above when date is None.
</p>


<h3>Multimedia: Sound, Music, and Movies</h3>

<h4>Sound</h4>

<p>
Ren'py supports playing sounds in the background, using the
renpy.play function. These sounds must be in wav files, but
may live in an archive file.
</p>

<!-- func renpy.play -->

<example>
$ renpy.play("quindar.wav")
e "Ground control to Major Tom."
</example>

<p>
Sounds can also be associated with buttons, menu choices, and
imagemaps becoming hovered and activated. See the section on
sound properties in styles for how to used this.
</p>

<h4>Music</h4>

<p>
Ren'Py supports playing music in the background of your
game. Theoretically, Ren'Py should support any format SDL_mixer
supports (mp3, ogg, midi, mod, and more), but we've only tested
mp3 and ogg support. The music that is currently playing is kept
as part of the interpreter state, and is restored when a player
loads a game or rolls back the game state, automatically.
</p>

<p>
Music must exist in real files (not archive files), named with
paths starting at the game directory. The filename that the music
is stored in is saved with the game state. If the filename changes
between game releases, the game will still proceed, but music that
was playing when the game was saved may be absent when the game is
loaded.
</p>

<p>
The playing of music is controlled by a pair of Python function
calls:
</p>

<!-- func renpy.music_start -->
<!-- func renpy.music_stop -->

<p>
Here's an example of a script fragment that comes with musical
accompaniment.
</p>

<example>
e "Lemma kept asking for support for playing music."

# Loads game/music/taps.mp3
$ renpy.music_start("music/taps.mp3")

show eileen flaming mad

e "Well, we'll show him."

$ renpy.music_stop()

show eileen wink

e "Just kidding."
</example>

<p>
The config.fade_music variable is used to control the fading out
of old music when a new track is started.
</p>

<h4>Movies</h4>

<p>
As of version 4.5, Ren'Py is capable of playing MPEG-1 movies. This
allows you to include video as part of your game. There are two ways
that this can be done. Displaying video in fullscreen mode allows
video to be scaled up to very large sizes, while displaying video in a
displayable allows it to be blended with images and text.
</p>

<p>
Displaying a video fullscreen allows it to take advantage of hardware
decode and scaling support. The downside of fullscreen mode is that
nothing else can be displayed while the movie is being displayed.
</p>

<p>
The easiest way to display a movie fullscreen is to display it using
the renpy.cutscene function. This function displays a movie for a
specified length of time. When that time has elapsed, or when the user
clicks to dismiss the movie, the movie ends and the function returns.
</p>

<!-- func renpy.movie_cutscene -->

<p>
Displaying a movie in a displayable is more difficult, but it allows
the movie to be mixed with rendered text and graphics. A downside of
this method is that the screen needs to be re-rendered with each
frame, a process that may be unacceptibly slow when the screen is
large. We don't recommend this when the game window is larger that
640x480.
</p>

<p>
To display a movie in a displayable, we must start the movie and show
a Movie displayable on the screen. The movie is then displayed on the
screen along with any other widget. When we no longer want to show it,
we need to stop the decoding of the movie and hide the displayable.
</p>

<!-- func Movie -->

<!-- func renpy.movie_start_displayable -->

<!-- func renpy.movie_stop -->

<example>
init:
    image movie = Movie()

$ renpy.movie_start_displayable("bg.mpg", (640, 480), -1)
scene movie
show eileen happy

e "I'm standing in front of a movie."

e "Isn't that keen?"

hide movie
$ renpy.movie_stop()
</example>

<p>
Whenever a movie is playing, it is expected to provide all sound that
the user hears. Ren'Py disables sound hardware for the duration of the
movie.
</p>

<example>
$ renpy.cutscene("On_Your_Mark.mpg", 394)
</example>

<h3>Configuration Variables</h3>

<p>
Much of the the configuration of Ren'Py is done using
configuration variable. These variable, when assigned in a python
block, change the behavior of the interpreter. As configuration
variables aren't saved, and many need to be set before the GUI
initializes, it makes sense to set all configuration variable
inside init blocks. An example setting of variables is:
</p>

<example>
init:
    $ config.screen_width = 640
    $ config.screen_width = 480
</example>

<dl>
<var name="config.screen_width" value="800">
This sets the width of the screen.
</var>

<var name="config.screen_height" value="600">
This sets the height of the screen.
</var>

<var name="config.window_icon" value="None">
If not None, this is expected to be the filename of an image giving
an icon that is used for the window.
</var>

<var name="config.sound" value="True">
If True, sound works. If False, the sound/mixer subsystem is
completely disabled.
</var>

<var name="config.debug" value="False">
Enables some minor debugging functionality (mostly by turning some
missing files into errors.) This should always be turned off in a
release.
</var>

<var name="config.debug_sound" value="False">
Enables debugging of sound functionality. This disables the
supression of errors when generating sound. However, if a sound
card is missing or flawed, then such errors are normal, and
enabling this may prevent Ren'Py from functioning normally. This
should always be False in a released game.
</var>

<var name="config.rollback_enabled" value="True">
Should the user be allowed to rollback the game? If set to False,
the user cannot interactively rollback. (The feature still works
for loading savegames when the script changes.)
</var>

<var name="config.rollback_length" value="128">
When there are more than this many statements in the rollback log,
Ren'Py will consider trimming the log.
</var>

<var name="config.hard_rollback_limit" value="10">
This is the number of steps that Ren'Py will let the user
interactively rollback. Set this to 0 to disable rollback
entirely, although we don't recommend that, as rollback is
useful to let the user see text he skipped by mistake.
</var>

<var name="config.profile" value="False">
If set to True, some profiling information will be output to
stdout (wherever that may go to).
</var>

<var name="config.image_cache_size" value="8">

This is used to set the size of the image cache, as a multiple of the
screen size.  This is mostly a suggestion, as if Ren'Py ever needs to
display more than this amount of images at once, it will cache
them all. But it will stop predictively loading images when the
cache is filled beyond this, and it will try to drop images from
the cache until it shrinks below this size. If this is too
small, there will be more disk access as images are loaded and
re-loaded. If this is too large, memory usage will be increased
as images are kept in memory.
</var>

<var name="config.predict_statements" value="10">
This is the number of statements, including the current one, to
consider when doing predictive image loading. A breadth-first
search from the current statement is performed until this many
statements is considered, and any image referenced in those
statements is potentially predictively loaded. Setting this to 0
will disable predictive loading of images.
</var>

<var name="config.debug_image_cache" value="False">
If True, Ren'Py will print the contents of the image cache to
standard output (wherever that goes) whenever the contents of
the image cache change.
</var>

<var name="config.load_before_transitions" value="True">
If True, the start of transitions will be delayed until the images
used by said transitions have finished loading.
</var>

<var name="config.allow_skipping" value="True">
If set to False, the user is not able to skip over the text of the
game.
</var>

<var name="config.fast_skipping" value="False">
Set this to True to allow fast skipping outside of developer
mode.
</var>

<var name="config.skip_delay" value="75">
The amount of time that dialogue will be shown for, when
skipping statements using ctrl, in milliseconds. (Although it's
nowhere near that precise in practice.)
</var>

<var name="config.archives" value="[ ]">
A list of archive files that will be searched for images.
</var>

<var name="config.searchpath" value="[ 'common', 'game' ]">
A list of directories that are searched for images, music, archives,
and other media, but not scripts. This is initialized to a list
containing "common" and the name of the game directory, which changes
depending on the name of the exe file. This variable is not used to
load scripts, as scripts will be loaded before it can be set.
</var>

<var name="config.mouse" value="None">
This variable controls the user of user-defined mouse cursors. If
None, the system mouse is used, which is usually a black-and-white
mouse cursor. Otherwise, this should be a dictionary giving the mouse
animations for various mouse types. Keys used by the default library
include "default", "say", "with", "menu", "prompt", "imagemap",
"pause", "mainmenu", and "gamemenu". The "default" key should always
be present. The values in the dictionary should be list of frames
making up the mouse cursor. Each frame is an (image, x-offset,
y-offset) tuple. Image is a filename of an image, while x- and y-
offset are the offsets of the hotspot within the image. The frames are
played back at 20hz, and the animation loops after all frames have
been shown. Please note that to show a frame more than once, it must
be repeated in a frame list. That is implemented efficiently.
</var>

<var name="config.focus_crossrange_penalty" value="1024">
This is the amount of penalty to apply to moves perpendicular to the
selected direction of motion, when moving focus with the keyboard.
</var>

<var name="config.sound_sample_rate" value="44100">
The sample rate that the sound card will be run at. If all of
your wav files are of a lower rate, changing this to that rate
may make things more efficent.
</var>

<var name="config.overlay_functions" value="[ ]">
A list of functions. When called, each function is expected to
return a list of displayables, which are added to the overlay
list. See the section on overlays for more.
</var>

<var name="config.fade_music" value="0.0">
This is the amount of time in seconds to spend fading the old track out
before a new music track starts. This should probably be fairly
short, so the wrong music doesn't play for too long.
</var>

<var name="config.keymap" value="dict(...)">
This variable contains a keymap giving the keys and mouse
buttons assigned to each possible operation. Please see the
section on keymaps for more information.
</var>

<var name="config.joystick" value="True">
Governs if joystick support is enabled. If False, Joystick detection
is disabled.
</var>

<var name="config.sticky_positions" value="False">
Sticky positions causes the at clause of a show or scene
statement to be remembered for as long as that character is on
the screen. Future show statements without at clauses will be
given the remembered at clause. This lets us easily change the
character's expression without changing their position on the
screen. Sticky positions does not interact well with multiple
layers, when they are used with the show, hide, and scene
statements via an onlayer clause.
</var>

<var name="config.layers" value="[ 'master', 'transient', 'overlay' ]">
This variable gives a list of all of the layers that Ren'Py knows
about, in the order that they will be displayed to the screen. (The
lowest layer is the first entry in the list.) Ren'Py uses the layers
"master", "transient", and "overlay" internally, so they should
always be in this list.
</var>

<var name="config.transient_layers" value="[ 'transient' ]" >
This variable gives a list of all of the transient layers. Transient
layers are layers that are cleared after each interaction. "transient"
should always be in this list.
</var>

<var name="config.overlay_layers" value="[ 'overlay' ]" >
This is a list of all of the overlay layers. Overlay layers are
cleared before the overlay functions are called. "overlay" should
always be in this list.
</var>

<var name="config.top_layers" value="[ ]" >
This is a list of names of layers that are displayed above all other
layers, and do not participate in a transition that is applied to all
layers. If a layer name is listed here, it should not be listed in
config.layers.
</var>

<var name="config.overlay_during_with" value="True" >
True if we want overlays to be shown during with statements, or False
if we'd prefer that they be hidden during the with statements.
</var>

<var name="config.with_callback" value="None">
If not None, this should be a function that is called when a with
statement occurs. This function can be responsible for putting up
transient things on the screen during the transition. The function is
called with a single argument, which is the transition that is
occuring. It is expected to return a transition, which may or may not
be the transition supplied as its argument.
</var>

<var name="config.enable_fast_dissolve" value="True" >
Setting this to False can fix a potential bug in the
dissolve transition when used with an overlay layer that has an alpha
channel that is not fully transparent or opaque, at the cost of 25% of
the performance of dissolve. It usually can be kept at True with no
ill effects.
</var>

<var name="config.text_tokenizer" value="..." >

<p>
This functions is used to tokenize text. It's called when laying
out a Text widget, and is given the string that is the text of the
widget, and the style associated with the widget.
</p><p>
It's expected to yield some number of pairs. In each pair, the
first element is the kind of token found, and the second element
is the text corresponding to that token. The following token
types are defined:
</p>
<ul>

<li>"newline" -- A newline, which when encountered starts a new line.</li>

<li>"word" -- A word of text. A line will never be broken inside of
a word.</li>

<li>"space" -- A space. Spaces are always placed on the current line,
and will never be placed as the start of a line.</li>

<li>"tag" -- A text tag. If encountered, the second element should be
the name of the tag, without any enclosing braces.</li>
</ul>
</var>

<var name="config.afm_characters" value="250">
The number of characters in a string it takes to cause the amount of time
specified in the auto forward mode preference to be delayed before
auto-forward mode takes effect.
</var>

<var name="config.afm_bonus" value="25">
The number of bonus characters added to every string when auto-forward
mode is in effect.
</var>

<var name="config.afm_callback" value="None">
If not None, a python function that is called to determine if it is
safe to auto-forward. The intent is that this can be used by a voice
system to disable auto-forwarding when a voice is playing.
</var>

<var name="config.auto_choice_delay" value="None">
If not None,this variable gives a number of seconds that Ren'Py will pause at an
in-game menu before picking a random choice from that menu. We'd
expect this variable to always be set to None in released games, but
setting it to a number will allow for automated demonstrations of
games without much human interaction.
</var>

<var name="config.font_replacement_map" value="{ }">
This is a map from (font, bold, italics) to (font, bold, italics),
used to replace a font with one that's specialized as having bold
and/or italics. For example, if you wanted to have everything using an
italic version of "Vera.ttf" use "VeraIt.ttf" instead, you could
write config.font_replacement_map["Vera.ttf", False, True] =
("VeraIt.ttf", False, False). Please note that these mappings only
apply to specific variants of a font. In this case, requests for a
bold italic version of vera will get a bold italic version of vera,
rather than a bold version of the italic vera.
</var>

<var name="config.interact_callbacks" value="...">
A list of functions that are called (without any arguments) when an
interaction is started or restarted.
</var>

<var name="config.start_interact_callbacks" value="...">
A list of functions that are called (without any arguments) when an
interaction is started. These callbacks are not called when an
interaction is restarted.
</var>

<var name="config.say_sustain_callbacks" value="...">
A list of functions that are called, without arguments, before the
second and later interactions caused by a line of dialogue with pauses
in it. Used to sustain voice through pauses.
</var>

<var name="config.editor" value="None">
If not None, this is expected to be a command-line for an editor that
is invoked when the launch_editor (normally shift-E) key is
pressed. There are two subsitutions that make sense here. %(filename)s
is replaced with the filename of the currently-executing line of
Ren'Py code. %(line)d is replaced with the line number of the
currently-executing line of Ren'Py code.
</var>

<var name="config.log" value="None">
If not None, this is expected to be a filename. Much of the text shown
to the user by say or menu statements will also be logged to this
file.
</var>

<var name="config.developer" value="False">
If set to True, developer mode is enabled.
</var>

<var name="config.lint_hooks" value="...">
This is a list of functions that are called, with no arguments, when
lint is run. The functions are expected to check the script data for 
errors, and print any they find to standard output (using the python
print statement is fine in this case).
</var>

<var name="config.hyperlink_callback" value="...">
A function that is called with the argument to a hyperlink when that
hyperlink is clicked. Defaults to a function that inteprets the
argument as a label, which is called in a new context when the
hyperlink is clicked.
</var>

<var name="config.periodic_callback" value="None">
If not None, this should be a function. The function is called, with
no arguments, at around 20hz.
</var>

<var name="library.script_version" value="None">
If not None, this is interpreted as a script version. The library will
use this script version to enable some compatibility features, if
necessary. If None, we assume this is a latest-version script.
</var>

<var name="library.file_page_cols" value = "2" >
This is the number of columns of save slots that are show in the
picker that's used in the load and save screens of the game
menu.
</var>

<var name="library.file_page_rows" value = "5" >
This is the number of rows of save slots that are show in the
picker that's used in the load and save screens of the game
menu.
</var>

<var name="library.file_quick_access_pages" value="5">
The number of pages of the file picker to provide quick access
to. Quick access is provided by number buttons which are at the top of
the file picker.
</var>

<var name="library.thumbnail_width" value="100">
The width of the thumbnails that are taken when the game is
saved. These thumbnails are shown when the game is
loaded. Please note that the thumbnail is shown at the size it
was taken at, rather than the value of this setting when the
thumbnail is shown to the user.
</var>

<var name="library.thumbnail_height" value="75">
The width of the thumbnails that are taken when the game is
saved. These thumbnails are shown when the game is
loaded. Please note that the thumbnail is shown at the size it
was taken at, rather than the value of this setting when the
thumbnail is shown to the user.
</var>

<var name="library.main_menu" value='[ ( "Start Game", "start", "True" ), ("Continue Game", ... ), ("Preferences", ... ), ("Quit Game", ...) ]'>
This is used to give the main menu that is shown to the user
when the game first starts. It is a list of tuples, where the
first element of each tuple is the title of the menu button, and
the second element is a label that we jump to when that button
is selected. (This jump exits the context in which the start
menu executes.) The second element may also be a function, in
which case it is called when the item is selected, in the menu
context. The third element in each tuple is an expression, which
is evaluated each time the main menu is displayed. If the expression
evaluates to false, the menu choice is disabled.
</var>

<var name="library.game_menu" value='[ ... ]'>
Thi is used to customize the choices on the game menu. Please read the
section on customizing the main and game menus for more details on the
contents of this variable.
</var>

<var name="library.main_menu_positions" value='None'>
If not None, this is a map between the default label for buttons on
the main menu, and a dictionary containing properties that are applied
to that button. This provides a simple way of customizing the main
menu by changing where buttons are located on the screen. Please note
that this disables the usual button-placement algorithm, so if one
button is positioned this way, all must be.
</var>

<var name="library.game_menu_positions" value='None'>
If not None, this is a map between the default label for buttons on
the game menu, and a dictionary containing properties that are applied
to that button. This provides a simple way of customizing the game
menu by changing where buttons are located on the screen. Please note
that this disables the usual button-placement algorithm, so if one
button is positioned this way, all must be.
</var>

<var name="library.preferences" value='{ ... }'>
This is used to customize the preferences. Please read the
section on customizing the main and game menus for more details on the
contents of this variable.
</var>

<var name="library.all_preferences" value='{ ... }'>
This is a map from preference name to the preference object
implementing that preference. This variable shouldn't be modified by
the user directly, but instead provides a stable source of preferences
that can be added to library.preferences.
</var>

<var name="library.joystick_keys" value='[ ... ]'>
This is a listing of all the joystick synthetic keys known to Ren'Py. 
It's a list of visible name, keysym pairs. Ren'Py uses this to
populate the joystick preferences.
</var>

<var name="library.has_music" value="True">
If True, the preference for enabling and disabling music will be
presented to the user. This should be set to False if the game
does not play any music.
</var>

<var name="library.has_sound" value="True">
If True, the preference for enabling and disabling sound effects
is presented to the user. This should be set to False if the
game does not have any sound effects.
</var>

<var name="library.has_cps" value="True">
If True, the preference for changing the text speed is shown to the
user.
</var>

<var name="library.has_afm" value="True">
If True, the preference for auto-forward mode is shown to the user.
</var>

<var name="library.has_transitions" value="True">
If True, the preference for enabling and disabling transitions
is presented to the user. This should be set to False if the
game does not have any transitions (that is, never uses the with
statement or clause).
</var>

<var name="library.has_skipping" value="True">
If True, the preference controlling what TAB and CTRL skip will be
shown to the user.
</var>

<var name="library.has_skip_after_choices" value="True">
If True, the preference enabling skip after choices will be shown
to the user.
</var>

<var name="library.hbox_pref_choices" value="False">
If True, the choice buttons in a preference will be placed together
in an hbox.
</var>

<var name="library.enter_sound" value="None">
If not None, this is a sound file that is played when entering
the game menu without clicking a button. (For example, when
right-clicking during the game.)
</var>

<var name="library.exit_sound" value="None">
If not None, this is a sound file that is played when exiting
the game menu without clicking a button. (For example, when
right-clicking inside the game menu.)
</var>

<var name="library.skip_indicator" value="True">
If True, the library will display a skip indicator when skipping
through the script.
</var>

<var name="library.enter_transition" value="None">
If not None, this variable should give a transition that will be
used when entering the game menu.
</var>

<var name="library.exit_transition" value="None">
If not None, this variable should give a transition that will be
performed when exiting the game menu.
</var>

<var name="library.sample_sound" value="None">
If not None, this variable should give a sample sound that is played
when the "Test" button on the volume slider is clicked. If None, then
the "Test" button is not shown.
</var>

<var name="library.main_menu_music" value="None">
If not None, a music file to play when at the main menu.
</var>

<var name="library.game_menu_music" value="None">
If not None, a music file to play when at the game menu.
</var>

<var name="library.always_has_joystick" value="False">
If True, the joystick interface is always available. This may be used
by people without joysticks to see the joystick interface for themeing
purposes.
</var>

</dl>

<h3>Properties and Styles</h3>

<p>
Ren'Py includes a style system that allows the user to control the
styles of text and windows (including things that inherit from
window, like buttons). A style inheritance mechanism allows a
single change to (for example) font size to affect the entire
game, while at the same time allowing fine-grained control when it
is desired.
</p>

<p>
A large number of styles are built into Ren'Py. It is possible to use
style.create to make your own styles.
</p>

<!-- func style.create -->

<p>
There are two families of style properties. Text properties are
used to control the font, size, and color of text, while window
properties are used to control the layout, background, and padding
of windows. If a widget displays text inside a window (as a
textbutton does), then it respects both text and window
properties. A widget is a Displayable that can accept properties.
</p>

<p>
Many style properties take as an argument RGBA tuples. These are
python tuples containing four values, representing the red, green,
blue, and alpha components of a color. Each of these values is a
number between 0 and 255. Alpha is used to control how opaque the
thing should be, with 0 being transparent, and 255 being fully
opaque. It's probably easiest to show an example of RGBA tuples
being used as part of styles.
</p>

<example>
init:

    # Selected menu choices should be yellow and solid.
    $ style.menu_choice.hover_color = (255, 255, 0, 255)

    # Unselected menu choices should be cyan and translucent.
    $ style.menu_choice.idle_color = (0, 255, 255, 128)
</example>


<h4>Text Properties</h4>

<p>
The following are properties that can be applied to Displayables
that take text styles.
</p>

<prop name="font">
The font that will be used to render text. This is either the name of 
a file containing a truetype font, or the name of a font. In the
former case, the font is loaded from the file. In the latter case, the
filename is used to search SFonts registered with register_sfont, and 
truetype fonts found on the system font directory. 
</prop>

<prop name="size">
The size of the font that is used to display the text on the
screen. Please note that the meaning of this can vary from font to
font, and bears only a weak relationship with the number of pixels
high that the font will be on the screen.
</prop>

<prop name="color">
The color in which the text will be displayed on the screen, as an
RGBA tuple. This is ignored when an SFont is used.
</prop>

<prop name="bold">
If True, then this text will be rendered in bold.
</prop>

<prop name="italic">
If True, then this text will be rendered in italics.
</prop>

<prop name="underline">
If true, then this text will be rendered with an underline.
</prop>

<prop name="antialias">
If True, the text will be antialiased. Otherwise, it will be left
jagged.
</prop>

<prop name="drop_shadow">
This is used to control the generation of a drop shadow on
text. It's either a 2-element tuple, or None. If it's a tuple,
then the 2 elements control the drop shadow offsets in X and Y,
respectively. (Both numbers should be positive for best results.)
If None, then no drop shadow is created for the text.
Example: (2, 3)
</prop>

<prop name="drop_shadow_color">
An RGBA tuple that's used to give the color of the drop shadow.
Example: (0, 0, 0, 128)
</prop>

<prop name="minwidth">
The minimum width in pixels of this text. If the rendered text is
smaller than this, it is right-padded with whitespace until it is
at least this many pixels long.
</prop>

<prop name="line_spacing">
This is used to increase or decrease the spacing between lines of
text by a constant number of pixels. A positive value increases, while
a negative value decreases the spacing.
</prop>

<prop name="text_y_fudge">
This fudges the y position of a block of text by adding whitespace
above the first line.
</prop>

<prop name="textalign">
This is used to control the horizontal alignment of the lines of
text in the area allocated to the Text widget containing that
text. It only really has any effect if the text is more than one
line long. It's a number between 0 and 1, which gives the fraction
of empty space that should be to the left of each line of
text. (To center text, it should be 0.5.)
</prop>

<prop name="first_indent">
This is used to give, in pixels, the indentation of the first line
of text in the text widget. It can be used to indent the first line of
a paragraph of text. (Not that that's a good idea on a computer
monitor, better to leave a blank line between paragraphs.)
</prop>

<prop name="rest_indent">
This is used to give, in pixels, the indentation of the second
and later lines of a text widget. It can be used to give a hanging
indent to quoted dialogue.
</prop>


<h4>Window Properties</h4>

<p>
Window properties are used to control the display of windows, and
other widgets that involve a rectangular area with a background
being displayed on the screen.
</p>

<prop name="background">
A Displayable that is used as the background for the window. This
needs to be a Displayable that always draws exactly the size
requested of it, which usually means either a Solid or a
renpy.Frame. This can also be None, which means that there is no
background on this window. (All the other window properties that
refer to a background still work. Just think of them as if their
background was transparent.) Example: Solid((0, 0, 128,
128))
</prop>

<prop name="left_margin">
The amount of transparent space left to the left of this window. If a
floating point number, it is scaled to the available width.
</prop>

<prop name="right_margin">
The amount of transparent space left to the right of this window. If a
floating point number, it is scaled to the available width.
</prop>

<prop name="top_margin">
The amount of transparent space left to the top of this window. If a
floating point number, it is scaled to the available height.
</prop>

<prop name="bottom_margin">
The amount of transparent space left to the bottom of this window. If a
floating point number, it is scaled to the available height.
</prop>

<prop name="xmargin">
This is a convenient (and backwards compatible) way of setting
left_margin and right_margin to the same value.
</prop>

<prop name="ymargin">
This is a convenient (and backwards compatible) way of setting
top_margin and bottom_margin to the same value.
</prop>

<prop name="left_padding">
The amount of space left between the edge of the border and the
left side of the contents of the window. If a float, it is scaled to the
width of the window.
</prop>

<prop name="right_padding">
The amount of space left between the edge of the border and the
right side of the contents of the window. If a float, it is scaled to the
width of the window.
</prop>

<prop name="top_padding">
The amount of space left between the edge of the border and the
top side of the contents of the window. If a float, it is scaled to the
height of the window.
</prop>

<prop name="bottom_padding">
The amount of space left between the edge of the border and the
bottom side of the contents of the window. If a float, it is scaled to the
height of the window.
</prop>

<prop name="xpadding">
A convenient (and backwards compatible) way of setting
left_padding and right_padding to the same value.
</prop>

<prop name="ypadding">
A convenient (and backwards compatible) way of setting
top_padding and bottom_padding to the same value.
</prop>

<prop name="xfill">
If True, the window will expand to fill all available space in the
x direction. If False, it will shrink to fit its contents.
</prop>

<prop name="yfill">
If True, the window will expand to fill all available space in the
y direction. If False, it will shrink to fit its contents.
</prop>

<prop name="xminimum">
The minimum size of this window in the x direction, including
margins and padding. If the window would be smaller than this, it
is grown to be at least this size. If a floating point number, it is
scaled to the available width.
</prop>

<prop name="yminimum">
The minimum size of this window in the y direction, including
margins and padding. If the window would be smaller than this, it
is grown to be at least this size. If a floating point number, it is
scaled to the available height.
</prop>


<h4>Position Properties</h4>

<p>
Position properties are applied to widgets that are smaller than
the space allocated to them. They apply to all widgets, and
control the placement of the widget in the space. For example,
position properties can be used to control the placement of a
dialogue window on the screen.
</p>

<p>
Position properties work best when a small widget is placed into
empty space. This is the case for say windows, and the menus that
are displayed as part of the main menu. Position properties work
on many updates, but the vagaries of how space is allocated by
widgets may make some of the results counterintuitive.
</p>

<p>
Positioning is done by specifying the placement of an anchor that
is part of a widget within the space allocated to that widget. The
position is either specified as an absolute number of pixels or a
fraction of the available space, while the position of the anchor
within the widget is done by selecting one of three settings for
each dimension.
</p>

<prop name="xpos">
Controls the positioning of the widget anchor in the x
dimension. If an integer, this is taken as the number of pixels to
the left of the anchor. If a float, this is taken as a fraction of
the available space in the x direction.
</prop>

<prop name="xanchor">
Controls the placement of the anchor within the widget, in the x
dimension. This can be one of 'left', 'center', or 'right', or a
number between 0 and 1, where 0 is the left edge and 1 is the
right edge.
</prop>

<prop name="ypos">
Controls the positioning of the widget anchor in the y
dimension. If an integer, this is taken as the number of pixels to
the left of the anchor. If a float, this is taken as a fraction of
the available space in the y direction.
</prop>

<prop name="yanchor">
Controls the placement of the anchor within the widget, in the y
dimension. This can be one of 'top', 'center', or 'bottom', or a
number between 0 and 1, where 0 is the top edge and 1 is the
bottom edge.
</prop>

<prop name="xmaximum">
If not None, this property gives the maximum width of this widget.
(Most widgets respect this, but some have a fixed size which this
does not change.)
</prop>

<prop name="ymaximum">
If not None, this property gives the maximum height of this widget.
(Most widgets respect this, but some have a fixed size which this
does not change.)
</prop>

<h4>Sound Properties</h4>

<p>
Some widgets can take sound style properties. These widgets can cause
a sound to play when they become hovered (see below), and also
when they are selected. Currently, the styles that can take sound
properties belong to buttons, imagemaps, and menu choices. Sound
style properties are either the name of a wav file which is played
with renpy.play when appropriate event occurs, or None to disable
sound playback.
</p>

<prop name="hover_sound">
The sound to play when this widget becomes hovered.
</prop>

<prop name="activate_sound">
The sound to play when the widget is activated, by clicking on or
otherwise selecting it.
</prop>

<h4>Bar Properties</h4>

<p>
The ui.bar() widget has a few properties that are specific to
it, that control the look of the bars. The bar has gutters on the left
and the right. The remaining space is the space in which the bar can
change, with the division of the bar being the fraction of this space
representing the bar's value as a fraction of the range.
</p>

<p>
When the bar is drawn, the thumb's shadow is drawn first, followed by
the left and right sides of the bar, followed by the thumb.
</p>

<prop name="left_gutter">
The size of the left gutter of the bar, in pixels.
</prop>

<prop name="right_gutter">
The size of the right gutter of the bar, in pixels.
</prop>

<prop name="left_bar">
A Displayable that is used to draw the left side of the bar. This
displayable is first rendered at the full size of the bar, and then
cropped so only the left side is visible.
</prop>

<prop name="right_bar">
A Displayable that is used to draw the right side of the bar. This
displayable is first rendered at the full size of the bar, and then
cropped so only the right side is visible.
</prop>

<prop name="thumb">
If not None, this is a thumb image that is drawn near the break
between the left and right side of the bar.
</prop>

<prop name="thumb_shadow">
If not None, a shadow of the thumb that is drawn underneath the
break between the left and right side of the bar.
</prop>

<prop name="thumb_offset">
The horizontal update between the division in the bar and the left
side of the thumb, in pixels. This will often be negative, so that the
thumb overlaps the division to some extent.
</prop>

<h4>Box Properties</h4>

<p>
Horizontal and Vertical boxes have a number of properties that can
be used to control how they are laid out. By changing these
properties, one can control the spacing between elements in a box, and
even turn a box from horizontal to vertical (or vice versa).
</p>

<prop name="box_spacing">
The spacing between elements in the box.
</prop>

<prop name="box_first_spacing">
If not None, the spacing between the first two elements in the box.
</prop>

<prop name="box_layout">
If "horizontal", the box is laid out in a horizontal manner. If
"vertical", the box is laid out in a vertical fashion. If None, the
layout of the box is controlled by the function that created the
box, with ui.hbox and ui.vbox making horizontal and vertical boxes,
respectively.
</prop>

<prop name="xfill">
If True, the box will expand to fill all available space in the
x direction. If False, it will shrink to fit its contents.
</prop>

<prop name="yfill">
If True, the box will expand to fill all available space in the
y direction. If False, it will shrink to fit its contents.
</prop>



<h4>Hovering</h4>

<p>
In Ren'Py, buttons and their contents support the idea of
hovering: using different sets of properties for different states
of the widget. If the widget cannot be given focus, it is
considered to be insensitive. If the widget has been selected by
the user, it is considered to be activated. Otherwise, if the
widget has focus, then that widget is hovered, else it is idle. On
these widgets, Ren'Py will look up a property prefixed with
"insensitive_", "activate_", "hover_", or "idle_" (as appropriate)
in a style, before looking up an unprefixed property. If neither
form is found on a style, the process is repeated again on the
parent style. (The search pattern for background on a hovered
button goes: button.hover_background, button.background,
default.hover_background, default.background.)
</p>

<p>
The only time an activated widget will be seen by the user is if a
transition occurs immediately after the widget has been activated.
</p>

<p>
As an example, take assigning a background to buttons that changes
when the button is hovered over.
</p>

<example>
init:
    style.button.hover_background = Solid((255, 255, 255, 255))
    style.button.idle_background = Solid((0, 0, 0, 255))
</example>

<prop name="enable_hover">
This property must be set to True (the default) on the style of a
hoverable widget (like a button) for hovering to be
enabled. Setting it to False speeds up Ren'Py, at the cost of
making the widget not respond to hovering.
</prop>

<h4>Using Properties and Styles</h4>

<p>
For properties to be useful, there needs to be a way to change the
properties associated with a given widget. Ren'Py provides several
ways to do this.
</p>

<p>
The most common way to do this is to change the definition of one
of the standard styles. Widgets that use this style, or one of the
styles that inherits from it, will pick up the change and change
how they are displayed.
</p>

<p>
The following example code ensures that the label of a button is
colored light green and aligned to the left. It also changes the
background images that are used when the button is idled and
hovered.
</p>

<example>
init:
    $ style.button.color = (128, 255, 128, 255)
    $ style.button.xpos = 0
    $ style.button.idle_background = \
          renpy.Frame(renpy.Image("button_idled.png"),
                      xborder=10, yborder=10)
    $ style.button_hover.background = \
          renpy.Frame(renpy.Image("button_hover.png"),
                      xborder=10, yborder=10)
</example>

<p>
This is the only way to change the look of widgets that are
automatically generated, such as those used to implement the
interface of the say and menu statements, except for say
statements that are routed through an object, like a character
object.
</p>

<p>
The second way to change the look of a widget is to change the
name of the style associated with that widgets. All widgets have
one or more parameters that take styles that the widget
take on. One can define a new style using style.new_style, and
modify that style, and tell widgets to use that style when
appropriate.
</p>

<p>
While normally new styles can only be assigned to widgets
constructed by the user, there are some exceptions to this
rule. The Character object takes as optional arguments styles that
are given to the say window, character name, and dialogue text.
</p>

<p>
The final way of assigning properties is to list them as keyword
arguments on a constructor that takes properties. (Indicated by
having **properties in its argument list.) Properties that are
given in this way take precedence over all other properties. The
Character argument also takes properties that are applied to the
window and the label.
</p>

<h4>Standard Styles</h4>

<p>
In this section find a list of the standard styles that come with
Ren'Py, either built-in or in the standard library. Before each in
parentheses, we list the types of properties that are used on the
style, and "hover" if the default use of the style supports
hovering.
</p>

<dl>

<!-- include styles.xml -->

</dl>

<h3>Text Tags</h3>

<p>
Styles are useful if you want to change the look of entire blocks
of text in the game. But what if you only want to change the look of a
small amount of text, or if you want to only change the look of entire
blocks of text. Text tags let you change the look of text within a
single text widget.
</p>

<p>
Text tags work wherever text can be placed. This means that they can
be used inside text widgets, text buttons, and menu and say
statements. But please note that say statement protect from
subsituting in a text tag, as that would most likely be an
error. Generally, though, if Ren'Py shows text to the user, that text
can be formatted through the use of text tags.
</p>

<p>
As an aside, let me point out that if you're using a text tag on every
line of a script, or even many lines, you're probably doing something
wrong. That's what styles are for.
</p>

<p>
Text tags start with a left brace, and continue to the matching right
brace. We chose to use braces because they do not require quoting in
HTML or BBCode. An open text tag may take a parameter, and then continues until
a closing tag, which is a tag that has a slash immediately after the
opening brace. Please note that text tags are sensitive to both case
and whitespace.
</p>

<p>
Some example tags are {b}, {i}, {color=#f88}, {size=+16}, and {font=VeraIt.ttf}. The matching
closing tags are {/b}, {i}, {/color}, {/size}, and {/font}. Tags must be
properly nested: "{b}{i}bold + italic{/i}{/b}" is okay,
but "{b}{i}this is wrong{/b}{/i}". Right now, improper nesting won't
cause an error but it probably won't do what you want. All open tags
must be closed by the end of the string.
</p>

<p>
There are two tags, {w} and {p}, that can only be used in
dialogue. These tags cause a pause in the display of text, until the
user clicks to continue, or an auto-forward occurs. This allows text
to be displayed incrementally. The difference between {w} and {p} is
that {p} adds a line break at the pause point. They do not use a
closing tag.
</p>

<p>
There is a tag, {fast}, that only has an effect if the text speed is
not infinite. This tag specifies where slow text should begin
displaying from. Use this if you have two lines of dialogue where the
second is an extension of the first. (This is an alternate way of
achieving the pause effect.) This tag does not take a closing tag.
</p>

<p>
There is also an image tag {image=filename}, where filename is the name
of an image file. The image tag does not take a closing tag. Images so
including are placed as if they were text, and should be no larger
than a single line of text.
</p>

<p>
If you, for some reason, want to include a left brace, just write two
left braces ({{) instead.
</p>

<h4>Supported Text Tags</h4>

<p>The following are supported text tags:</p>

<ul>

<li>{b}text{/b} makes the enclosed text bold.</li>

<li>{i}text{/i} makes the enclosed text italic.</li>

<li>{u}text{/u} makes the enclosed text underlined.</li>

<li>{plain}text{/plain} makes the enclosed text plain, which means that
it is not bold, italic, or underlined.</li>

<li>{size=<i>spec</i>}text{/size} changes the size of the text. The
supplied spec may be a number, in which case it is the number of
pixels high that the text will be. If it is a number preceded by a
plus (like "+10"), it means to increase the size by that number of
pixels, while if it is preceded by a minus it means to decrease.
</li>

<li>{color=<i>spec</i>}text{/color} changes the color of the text. The
color may be a hex triple or a hex sextuple, optionally preceded by a
hash mark. (This is the same format that color() accepts.)</li>

</ul>

<p>
Here's an example of a say statement that uses many of the text
tags. If you actually use this many text tags in a real game, you'll
probably drive your users mad.
</p>

<example>
"Using text tags, we can make text {size=+12}bigger{/size} or
 {size=-8}smaller{/size}. We can make it {b}bold{/b}, {i}italic{/i},
 or {u}underlined{/u}. We can even change its {color=#f88}color{/color}."
</example>

<h3>SFonts</h3>

<p>
Ren'Py supports rendering text using SFonts as well as TrueType
fonts. An SFont is a properly prepared image file, usually a PNG,
containing images of the character in the font. Ren'Py has its own
implementation of SFonts that supports an arbitrary unicode character
set and kerning. 
</p>

<p>
SFonts have several advantages and several disadvantages. One of
the advantages is that SFonts are bitmap-based. This allows them to be
distributed without having to worry about the copyrights associated
with TrueType fonts (consult your lawyer!). Also, as SFonts are
images, it's possible to apply effects to them that Ren'Py would not
otherwise support. The downsides of SFonts come from the fact that
Ren'Py isn't rendering. Because of this, one needs to supply another
image to Ren'Py if one wants the font to be scaled, made bold or
italic, underlined, or colorized.
</p>

<p>
To use SFonts, they must first be registered with Ren'Py using the
renpy.register_sfont function. They can then be used by setting the
font property of a style to the name of the SFont.
</p>

<!-- func renpy.register_sfont -->

<p>
The default character set for the font is:
</p>

<pre>
! " # $ % &amp; ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; &lt; = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~
</pre>

<p>
Please note that you must register a sfont for each combination of
font, size, bold, italic, and underline your game uses. Also note that
since SFonts can't be recolored, one must register under a separate
font name for each color. (Especially important when SFonts are
used for button labels, to ensure that selected buttons look distinct
from unselected ones.)
</p>

<h3>Obfuscating your Game</h3>

<p>
For some reason, many people seem to want to distribute their
games in an obfuscated form, making it difficult to read the
script, or to view the images associated with a game. Ren'Py
supports this, to a point, by compiling scripts and allowing
images to be archived. While a moderately skilled programmer could
easily crack this obfuscation, it should be enough to protect a
game from casual browsing.
</p>

<p>
Obfuscating the script is practically automatic. Every time the
game runs, any .rpy file in the game directory is written out as an
.rpyc file. These .rpyc files are enough to run the game, so simply
running the game once (to create the .rpyc files) and then
deleting (or more appropriately, moving away) the .rpy files will
leave you with a runnable game with an obfuscated script. As a
bonus, the .rpyc files are already parsed, improving game load
time. (If a directory contains .rpy and .rpyc files with the same
stem, the newer one of them is chosen, meaning all games get this
performance improvement.)
</p>

<p>
Running Ren'Py with the --lock <i>key</i> command-line option will
produce .rpyc files that are locked. These files will refuse to
operate if a .rpyc file locked with a different key, or any .rpy file,
would be loaded. Please note that this feature is discouraged, as it
prevents the easy production of patches that work around issues in
your game.
</p>


<p>
Images can be archived using the tools/archiver program
that ships as part of Ren'Py. To use this, one can change
into the game directory and run a command like:
</p>

<p>
<kbd>../tools/archiver images *.png *.jpg</kbd>
</p>

<p>
Alternatively on Windows, one can run tools/game_archive_images.bat
directly, which will do the same thing.
</p>

<p>
This will create the file images.rpa in the game
directory. One can then add to the script a line like:
</p>

<example>
init:
    $ config.archives = [ 'images' ]
</example>

<p>
Then, delete the .jpg and .png files from the game
directory. Ren'Py will look in the images archive to find images
that need to be loaded.
</p>

<h3>Localizing Ren'Py</h3>

<p>
While Ren'Py is by default set up to operate in an English
speaking environment, it is not limited to such settings. Assuming
a proper font is loaded, Ren'Py scripts can contain any language
expressible in Unicode.
</p>

<p>
There are two things in the Ren'Py library that may need to be
translated into a user's language. The first is the main
menu. There is no explicit support for doing this, but as the
library.main_menu variable supports changing the text of the main
menu, it also supports translating said text.
</p>

<p>
The second thing that needs to be translated is the game menu. The
library.translations dictionary is used to translate text in the
game menu into your language. If a key in this map corresponds to
the English text that would be displayed, the value corresponding
to that key is displayed again. For example:
</p>

<example>
init:
    $ library.translations = {
        "Yes" : u"HIja'",
        "No" : u"ghobe'",
        # etc.
        }
</example>

<p>
The u characters prefixed to the strings on the right, while not
strictly necessary in this case, are used to tell Python that the
string is in Unicode rather than ASCII. This is useful if your
language uses non-ascii characters.
</p>

<h3>Changing the Keymap</h3>

<p>
The variable config.keymap contains a map from functions that can be
performed by the various user-interface elements of Ren'Py to a list
of keysyms that actually perform those functions. Modifying the
contents of the keymap can change the keys and mouse buttons that
cause things to happen.
</p>

<p>
While this functionality has been added to Ren'Py at a user's request
(and because it simplifies the Ren'Py code), it's not altogether clear
that it should be used. Having a common set of keybindings makes games
easier to play, by reducing the learning curve of users. It's probably
better to build consensus around a change in keybindings, rather than
unilaterally making something different from everyone else.
</p>

<p>
Anyway, in Ren'Py keysyms are strings. The first kind of keysym is of
the form 'mouseup_#' or 'mousedown_#', for a number between 1 and 5. These keysyms are
generated by mouse button presses, releases, or turns of the mouse wheel. For
example, "mousedown_1" is generally a press of the left mouse button,
"mouseup_1" is a release of that button, and "mousedown_4" is a turn of the the mouse wheel to the top.
</p>

<p>
A second kind of keysym is a joystick keysym. These begin with
joy_. They are defined in library.joystick_keys, and mapped to
actual joystick events by the user.
</p>

<p>
A third kind of keysym is a string containing a character that is
generated when a key is pressed. This is useful for binding alphabetic
keys and numbers. Examples of these keysyms include "a", "A", and
"7".
</p>

<p>
The final kind of keysym is the symbolic name for the key. This can be
any of the K_ constants taken from
<a href="http://www.pygame.org/docs/ref/pygame_constants.html">pygame.constants</a>
This type of keysym looks like "K_BACKSPACE", "K_RETURN", and "K_TAB".
</p>

<p>
To change a binding, update the appropriate list in
config.keymap. The following code adds the 't' key to the list of
keys that dismiss a say statement, and removes the space key from
that list.
</p>

<example>
init:
    $ config.keymap['dismiss'].append('t')
    $ config.keymap['dismiss'].remove('K_SPACE')
</example>

<p>
The default keymap is contained inside the python code implementing
Ren'Py, and as of version 5.3.1 is as follows:
</p>

<example>
config.keymap = dict(
    
    # Bindings present almost everywhere, unless explicitly
    # disabled.
    rollback = [ 'K_PAGEUP', 'mousedown_4', 'joy_rollback' ],
    screenshot = [ 's' ],
    toggle_fullscreen = [ 'f' ],
    toggle_music = [ 'm' ],
    game_menu = [ 'K_ESCAPE', 'mouseup_3', 'joy_menu' ],
    hide_windows = [ 'mouseup_2', 'h' ],
    launch_editor = [ 'E' ],

    # Say.
    rollforward = [ 'mousedown_5', 'K_PAGEDOWN' ],
    dismiss = [ 'mouseup_1', 'K_RETURN', 'K_SPACE', 'K_KP_ENTER', 'joy_dismiss' ],

    # Focus.
    focus_left = [ 'K_LEFT', 'K_KP_LEFT', 'joy_left' ],
    focus_right = [ 'K_RIGHT', 'K_KP_RIGHT', 'joy_right' ],
    focus_up = [ 'K_UP', 'K_KP_UP', 'joy_up' ],
    focus_down = [ 'K_DOWN', 'K_KP_DOWN', 'joy_down' ],
        
    # Button.
    button_select = [ 'mouseup_1', 'K_RETURN', 'K_KP_ENTER', 'joy_dismiss' ],

    # Input.
    input_backspace = [ 'K_BACKSPACE' ],
    input_enter = [ 'K_RETURN', 'K_KP_ENTER' ],

    # These keys control skipping.
    skip = [ 'K_LCTRL', 'K_RCTRL' ],
    toggle_skip = [ 'K_TAB', 'joy_skip' ],
    fast_skip = [ '>' ],

    # These control the bar.
    bar_activate = [ 'mousedown_1', 'K_RETURN', 'K_KP_ENTER', 'joy_dismiss' ],
    bar_deactivate = [ 'mouseup_1', 'K_RETURN', 'K_KP_ENTER', 'joy_dismiss' ],
    bar_decrease = [ 'K_LEFT', 'joy_left' ],
    bar_increase = [ 'K_RIGHT', 'joy_right' ],
    )
</example>

<h3>UI Functions</h3>

<p>
While it's hoped that Ren'Py say and menu statements will be
appropriate for much of the user interaction that goes on in a visual
novel, we recognize that not all games can be fit in such a mold. To
allow other, similar, games to be built, we've exposed the functions
that we use to build the Ren'Py user interface. These functions are
used both for normal gameplay, and to build the main and game
menus. While these functions won't be enough for all games (Ren'Py
will never be a RPG engine), hopefully these will allow the creation
of, for example, schedule-management dating-simulation games.
</p>

<p>
To start, let's give a script snippet that uses the UI functions.
The following displays a window containing three buttons, arraigned
horizontally. The string assigned to choice varies depending on which
of the three is picked.
</p>

<example>
$ ui.window()
$ ui.hbox()

$ ui.textbutton("A", clicked=ui.returns("A"))
$ ui.textbutton("B", clicked=ui.returns("B"))
$ ui.textbutton("C", clicked=ui.returns("C"))

$ ui.close()
$ choice = ui.interact(suppress_overlay=True)
</example>

<p>
To understand the ui functions, you must first understand the three
kinds of widgets that Ren'Py supports. The first kind of widget (of
which window is one), takes a single child widget. When this kind of
widget is open, the next widget to be created is added to it, and it
then closes automatically.
</p>

<p>
A second kind of widget can take an arbitrary number of child
widgets. This kind of widget is exemplified by the layout widgets:
vbox, hbox, and fixed. New widgets are added to this kind of widget
until a matching call to ui.close() occurs, unless they are instead
added to an open child of this widget.
</p>

<p>
The final kind of widget cannot take any children. This kind of
widget is exemplified by textbutton.
</p>

<p>
Nothing is displayed on the screen until ui.interact() is called. Once
it has been called, Ren'Py displays the screen to the user. It then
waits for a widget to return a value. In the example given above, when
a textbutton is clicked, the function returned by ui.returns is
called, which in turn causes ui.interact to return the same
value. When ui.interact returns, the screed is cleared of all
transient ui elements, and control proceeds with the next
statement. The ui functions must be called again if we want to show
the same user interface to the user again.
</p>

<p>
It's important to ensure that, if a lambda or nested function is used
as an argument to one of these ui functions, ui.interact() is called
in the same python block. Failure to do this will prevent your game
from saving, and that's probably a bad thing. ui.returns doesn't
suffer from this problem, and so should probably be used in preference
to lambda.
</p>

<p>
By default, widgets are added to the 'transient' layer. This can be
changed by a call to ui.layer(), followed by a matching call to
ui.close() when done adding widgets to the new layer.
</p>

<p>
Widgets can be added to a focus group by supplying the name of the
focus group as the focus parameter to a ui widget. If the same focus
group exists on two interactions, Ren'Py will ensure that if the nth
widget is selected in the first interaction, the nth widget will be
given focus at the start of the second interaction. If no widget is
given focus in this way, then Ren'Py looks for one that has had the
default=True argument supplied to it. If it finds such a widget, then
it focuses it. Otherwise, it uses fallback rules to determine if a
widget should be given focus.
</p>

<p>
The following are the functions available in the ui module, which is
automatically present in the game namespace.
</p>

<h4>Single-Child Widgets</h4>

<!-- func ui.window -->

<!-- func ui.frame -->

<!-- func ui.button -->

<!-- func ui.sizer -->

<h4>Multiple-Child Widgets</h4>

<!-- func ui.vbox -->

<!-- func ui.hbox -->

<!-- func ui.grid -->

<!-- func ui.fixed -->

<h4>No-Child Widgets and Psuedo-Widgets</h4>

<!-- func ui.text -->

<!-- func ui.image -->

<!-- func ui.textbutton -->

<!-- func ui.imagebutton -->

<!-- func ui.imagemap -->

<!-- func ui.menu -->

<!-- func ui.bar -->

<!-- func ui.null -->

<!-- func ui.saybehavior -->

<!-- func ui.pausebehavior -->

<h4>Functions</h4>

<!-- func ui.add -->

<!-- func ui.clear -->

<!-- func ui.interact -->

<!-- func ui.layer -->

<!-- func ui.close -->

<function name="ui.returns" sig="(value)">
<p>
This function returns a function that, when called, returns the
supplied value. It's best used to supply the clicked argument to the
various button widgets.
</p>
</function>

<function name="ui.jumps" sig="(label)">
<p>
This function returns a function that, when called, jumps the game to
the given label, ending the current interaction in the process. It's
best used to supply the clicked argument to the various button
widgets.
</p>
</function>

<function name="ui.jumpsoutofcontext" sig="(label)">
<p>
This function returns a function that, when called, exits the current
context, and in the parent context jumps to the named label. It's
intended to be used as the clicked argument to a button.
</p>
</function>

<h3>Image Manipulators</h3>

<p>
Image manipulators are objects that can return images. Every image
manipulator can be used as a widget, but the opposite is not
true. Image manipulators are used to implement the Image function,
but constructing them directly can give you finer control.
</p>

<p>
When an image manipulator requires another as input, the second image
manipulator can be specified in any of a number of ways. The first way
is as a string, which is turned into an im.Image. The second is a
tuple, which is turned into an im.Composite using the rules for tuples
given in Image. The third is that an image manipulator can be
specified directly, in which case it is passed through unchanged.
</p>

<p>
Widgets may not be used as arguments to image manipulators. This is
because image manipulators are very efficent, caching the computed
images on their first load.
</p>

<p>
The image manipulators are:
</p>

<!-- func im.Image -->

<!-- func im.Crop -->

<!-- func im.Scale -->

<!-- func im.Rotozoom -->

<!-- func im.Recolor -->

<!-- func im.Alpha -->

<!-- func im.Map -->

<!-- func im.ramp -->

<!-- func im.Tile -->

<!-- func im.Composite -->

<h3>Low-Level Audio Functions</h3>

<p>
Here, we give functions that allow for low-level control of the audio
subsystem. There are two kinds of audio that we can play. The sound
subsystem plays audio, but doesn't attempt in any way to make the
audio that is played persistent. The music subsystem, on the other
hand, handles saving and restoring the music as the game's situation
changes. Use the sound functions to play sound effects, or to
implement your own method of playing music. Use the music functions
when you want music to be restored after playing and loading.
</p>

<p>
Ren'Py supports 8 channels of audio. The first three channels (0-2)
are dedicated to sound effects, while the rest (3-7) are intended for
music. When voice is used, channel 2 is reserved for voice. All
channels support playing compressed waveform audio. We support wav,
mp3, ogg vorbis, ogg speex, and various mod formats, including xm. We
also support midi, but impose that the requirement that only one
channel can be playing midi at a time.
</p>

<p>
Both sound and music functions deal with a queue of audio files. This
queue contains the files that will be played after the currently
playing file finishes. When looping, if the queue becomes empty the
last-queued file is added to the queue.
</p>

<p>
When synchro-start is enabled on two or more channels, the system
waits for all of the channels to stop playing before playing the new
files on those channels. All of the channels are started
simultaneously, in a sample-accurate manner.
</p>

<h4>Sound Functions</h4>

<!-- func renpy.sound.play -->

<!-- func renpy.sound.queue -->

<!-- func renpy.sound.stop -->

<!-- func renpy.sound.is_playing -->

<!-- func renpy.sound.set_volume -->

<!-- func renpy.sound.set_mixer -->

<!-- func renpy.sound.set_queue_empty_callback -->


<h4>Music Functions</h4>

<p>
The music functions persists the information about playing music,
allowing the music to be restored after a rollback, return from a
menu, or load. What is saved is the time of the last change of music,
and the last queued file or files. If the persistent time of last music change
is different than what is currently playing, the system dequeues all
queued music. It then check to see if the playing music is not one of the
from the persisted last queued music filenames. If so, it stops the playing
music. It then plays in a loop the last queued music, and sets the
currently known last change time to the persisted last change time.
</p>

<!-- func renpy.music.play -->
<!-- func renpy.music.queue -->
<!-- func renpy.music.stop -->
<!-- func renpy.music.set_volume -->
<!-- func renpy.music.set_music -->

<h3>Customizing the Main and Game Menus</h3>

<p>
This section describes how the content of the various menus can be
customized. If you just want to change the look of the menus (to the
extent made possible by the style system), use styles. To change just
the text of menu items, consider using library.translations. To change
just the position of buttons in a menu, use
library.game_menu_positions and library.main_menu_positions.
</p>

<h4>Main Menu</h4>

<p>
The main menu can be customized by setting the library.main_menu
variable. This variable should be a list of pairs. The first element
of each pair is the name of the button on the main menu. The second
item can be one of three things. It can be a string, in which case it
is a label at which the game execution starts (after a jump out of the
menu context). It can be a function, in which cas the function is
called when the button is clicked. Finally, it can be None, which
causes the button to be insensitive.
</p>

<p>
If one wants to change the main menu each time it is invoked, but keep
the look of it the same, then the thing to do is to provide a
main_menu label. The code after this main_menu label should set
library.main_menu, and then jump to _library_main_menu. This is
useful, for example, if there are some items in the main menu that
should be absent or disabled until some condition is met. (Say, the
user reaching an ending for the first time.)
</p>

<p>
Finally, it may be desirable to write your own menu from scratch. This
is done by creating the menu using ui functions called from code
invoked through the main_menu label. To start the game, the code
should jump out of the context, using ui.jumpsoutofcontext() or
renpy.jump_out_of_context(). The code can also jump to any of the game
menu screens, which can be reached at the labels "_load_screen",
"_save_screen" and "_prefs_screen", to display the appropriate
screen. When interacting with the user, ui.interact() should be called
with suppress_overlay=True, suppress_underlay=True, and perhaps
mouse="mainmenu".
</p>

<p>
The functions that are used to make a game menu screen, _game_nav()
and _game_interact(), should also work with the main menu
screen. When necessary, renpy.context().main_menu can be checked to
see if we are in the main menu (it is True) or game menu (it is
False).
</p>

<h4>Game Menu</h4>

<p>
The first thing one may wish to do when modifying the game menu is to
add a screen to it. This is done in two steps. The first is to create
the screen, and the second is to add it to the library.game_menu list
so that it can be reached from the game menu.
</p>

<p>
Each screen is represented in the code as a label that is jumped to to
display the screen. There are five steps that this label should do in
order to display the screen. First, it should call _game_nav(screen),
where screen is the name of the screen (the first component of the
tuples in library.game_menu, described below). Second, it should call
the ui functions to actually draw the screen. Third, it should call
_game_interact, instead of ui.interact, to interact with the
user. This ensures that the game menu interaction is handled
properly. Fourth, it should examine the results of _game_interact, and
react appropriately. Finally, it should jump back up to the screen
label, showing the screen again after each interaction.
</p>

<p>
So that the user can see it, the screen should be added to
library.game_menu. This is a list of four-component tuples. The first
is the name of the screen. It's used to determine if the button used
to reach that screen should be indicated as selected. The second
component is the text used for that button.  The third component is a
function that executes when the button is clicked. Normally, an
appropriate function is ui.jumps('label'), where label is the name of
the label under which your screen was defined above. Finally, the
fourth parameter is a string containing a python expression. If the
expression is not true, the button is insensitive.
</p>

<p>
To customize the game menu navigation buttons, one can customize
_game_nav(). This takes one parameter, the screen we're at. Default
parameters for this are "restart", "load", "save", "prefs",
"quit".
</p>

<var name="game_nav" value='"_load_screen"'>
One can customize the screen the game menu jumps to by default by
changing the value of _game_menu_screen. For example, one could set
this to "_load_screen" for the first few interactions, and then set it
to "_save_screen" for the rest of the game. This is especially useful
for a game with no main menu.
</var>

<p>
There is a convenience function for prompting the user for their
response to a yes and no question.
</p>

<!-- func _yesno_prompt -->

<h4>Preferences</h4>

<p>
Finally, it is possible to customize the preferences. This is done by
modifying library.preferences, which is a dictionary mapping from vbox
style to a list of preferences to be placed in that vbox. Modifying
this dictionary and lists can move preferences around, and eliminate
preferences entirely. It may be desirable to create new vbox styles,
by using style.create().
</p>

<p>
To create an entirely new preference, create it with _Preference,
_SliderPreference, or _VolumePreference, and then add it to an
appropriate list in library.preferences.
</p>

<!-- func _Preference -->

<!-- func _SliderPreference -->

<!-- func _VolumePreference -->

<!-- func _remove_preference -->

<h3>Developer Tools</h3>

<p>
Ren'Py includes a number of features to make a developer's life
easier. Many of them need the variable <a href="#config.developer">config.developer</a> to be
set to True to operate.
</p>

<h4>Editor Support</h4>

<p>
The <a href="#config.editor">config.editor</a> variable allows a
developer to specify an editor command that is run when the
launch_editor keypress (by default, shift-E) occurs.
</p>

<p>
Please see <a href="http://www.bishoujo.us/renpy/scite.html">http://www.bishoujo.us/renpy/scite.html</a>
for information about how to integrate Ren'Py with the SciTE text editor.
</p>

<h4>Fast Skipping</h4>

<p>
When config.developer is True, pressing the fast_skip key (by
default, '>') causes the the game to immediately skip to the next important
interaction. For this purpose, an important interaction is one that is
not caused by a say statement, transition, or pause command. Usually,
this means skipping to the next menu, but it will also stop when
user-defined forms of interaction occur.
</p>

<h4>Warping to a Line</h4>

<p>
Ren'Py supports warping to a line in the script, without the developer
to play through the entire game to get there. While this warping
technique has a number of warnings associated with it, it still may be
useful in providing a live preview.
</p>

<p>
To invoke warping, run Ren'Py with the --warp command-line argument
followed by a filename:line combination, to specify where you would
like to warp to. For example:
</p>

<example>
run_game --warp script.rpy:458
</example>

<p>
When warping is invoked, Ren'Py does a number of things. It first
finds all of the scene statements in the program. It then tries to
find a path from the scene statements to every reachable statement in
the game. It then picks the reachable statement closest to, but
before or at, the given line. It works backwards from that statement
to a scene statement, recording the path it took. Ren'Py then executes
the scene statement and any show or hide statements found along that
path. Finally, it transfers control to the found statement.
</p>

<p>
There are a number of fairly major caveats to the warp feature. The
first is that it only examines a single path, which means that while
the path may be representative of some route of execution, it's
possible that there may be a bug along some other route. In general,
the path doesn't consider game logic, so it's also possible to have a
path that isn't actually reachable. (This is only really a problem on
control-heavy games, espcially those that use alot of python code.
</p>

<p>
The biggest problem, though, is that no python code is executed before
the statement that is warped to. This means that all variables will be
uninitalized, which can lead to crashes when they are used. To
overcome this, one can define a label 'after_warp', which is called
after a warp but before the warped-to statement executes. The code
reached by this label can set up variables in the program, and then
return to the preview.
</p>

<p>
The warp feature requires config.developer to be True to operate.
</p>


<h3>Default Definitions</h3>

<p>
This section documents a number of definitions that are found in the
Ren'Py standard library. These include default instatiations of the
various transitions and placements, and even one image.
</p>

<p>
These definitions are found in common/definitions.rpy. You
shouldn't change them there, but should instead copy the corresponding
line into your script file, and change that instead.
</p>

<h4>Positions</h4>

<dl>

<defn name="left" type="position">
A Position in which the left side of the image is aligned with the
left side of the screen.
</defn>

<defn name="right" type="position">
A position in which the right side of the image is aligned with the
right side of the screen.
</defn>

<defn name="center" type="position">
A position in which the image is centered horizontally on the screen.
</defn>

<defn name="offscreenleft" type="position">
A position in which the image is placed just off the left side of the
screen. Please note that an image placed in this position, while not
visible to the user, still consumes resources, and so images should be
hidden when not visible. This position is
intended to be used with the move transition.
</defn>

<defn name="offscreenright" type="position">
A position in which the image is placed just off the right side of the
screen. Please note that an image placed in this position, while not
visible to the user, still consumes resources, and so images should be
hidden when not visible. This position is
intended to be used with the move transition.
</defn>

</dl>


<h4>Transitions</h4>

<dl>

<defn name="fade" type="transition">
An instance of the Fade transition that takes 0.5 seconds to fade
to black, and then 0.5 seconds to fade to the new screen.
</defn>

<defn name="dissolve" type="transition">
An instance of the Dissolve transition that takes 0.5 seconds to complete.
</defn>

<defn name="pixellate" type="transition">
An instance of the Pixellate transition, which takes 1 second to
complete, and creates pixels as big as 32x32 over the course of 5
steps in either direction.
</defn>

<defn name="move" type="transition">
An instance of the MoveTransition transition, this takes 0.5 seconds
to move images that changed position to their new locations.
</defn>

<defn name="vpunch" type="transition">
When invoked, this transition shakes the screen vertically for a
quarter second.
</defn>

<defn name="hpunch" type="transition">
When invoked, this transition shakes the screen horizontally for a
quarter second.
</defn>

<defn name="blinds" type="transition">
Transitions the screen in a vertical blinds effect lasting 1 second.
</defn>

<defn name="squares" type="transition">
Transitions the screen in a vertical blinds effect lasting 1 second.
</defn>

<defn name="wiperight" type="transition">
An instance of CropMove that takes 1 second to wipe the screen right.
</defn>

<defn name="wipeleft" type="transition">
An instance of CropMove that takes 1 second to wipe the screen left.
</defn>

<defn name="wipeup" type="transition">
An instance of CropMove that takes 1 second to wipe the screen up.
</defn>

<defn name="wipedown" type="transition">
An instance of CropMove that takes 1 second to wipe the screen down.
</defn>

<defn name="slideright" type="transition">
An instance of CropMove that takes 1 second to slide the screen right.
</defn>

<defn name="slideleft" type="transition">
An instance of CropMove that takes 1 second to slide the screen left.
</defn>

<defn name="slideup" type="transition">
An instance of CropMove that takes 1 second to slide the screen up.
</defn>

<defn name="slidedown" type="transition">
An instance of CropMove that takes 1 second to slide the screen down.
</defn>

<defn name="slideawayright" type="transition">
An instance of CropMove that takes 1 second to slide the screen away and to the  right.
</defn>

<defn name="slideawayleft" type="transition">
An instance of CropMove that takes 1 second to slide the screen away and to the  left.
</defn>

<defn name="slideawayup" type="transition">
An instance of CropMove that takes 1 second to slide the screen away and to the  up.
</defn>

<defn name="slideawaydown" type="transition">
An instance of CropMove that takes 1 second to slide the screen away and to the  down.
</defn>

<defn name="irisout" type="transition">
An instance of CropMove that irises the screen out for 1 second.
</defn>

<defn name="irisin" type="transition">
An instance of CropMove that irises the screen in for 1 second.
</defn>

</dl>

<h4>Images</h4>

<dl>

<defn name="black" type="image">
This is a predefinition of a Solid black image. It's here to serve
as a reasonable default image, for use in tutorials and incomplete games.
</defn>

</dl>

<h3>Function Index</h3>

<funcindex/>

<h3>Variable Index</h3>

<varindex/>

<h3>Property Index</h3>

<propindex/>

<h3>Style Index</h3>

<styleindex/>

<h3>Style Hierarchy</h3>

<p>This shows the inheritance relationship between styles.</p>

<ul>
<!-- include style_heirarchy.xml -->
</ul>

<h3>Definition Index</h3>

<defnindex />

<h3>Example Script</h3>

<p>
For your browsing pleasure, we present a syntax-highlighted
version of the <a href="example.html">demo that ships with
Ren'Py</a>. The start of this script has been commented to make
it easier to understand.
</p>

</doc>

<!-- (define-key xml-mode-map [(control return)] 'tompy-xml-ctrlret) -->
<!-- -->

