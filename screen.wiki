<!-- -*- wikipedia -*- --> 
= Screen Language =

__TOC__

The user interface of a Ren'Py game is divided into screens. Some screens are shown to the user inside the game, including the screens for dialogue and menu choices. Other screens are used for the main menu and the game menu. Ren'Py's screen language provides a flexible and mostly-declarative way of defining these screens.

Widgets are displayables that have a user interface function. A screen is a collection of widgets. There can be more than one screen displayed at a time, provided that a screen doesn't conflict with other shown screens. Generally, only the uppermost screen will accept input from the user, but screens are able to declare that they pass input to the next lower screen.


== Screen Language Basics ==

'''Syntax.''' Statements in the screen language share a common syntax. Each statement consists of a single logical line, followed by an optional block.

The first logical line begins with the statement names, which determines what kind of statement this is. The name is followed by space-separated positional arguments, if the statement takes any. The positional arguments are followed by space-separated keyword parameters. The first line ends with a colon if it takes a block. Otherwise, the statement ends at the end of the line.

A keyword parameter consists of a name, a space, and then a value for the parameter. The value is parsed as a simple_expression, unless a more specific parsing method is noted in the parameter's description.

There are two kinds of lines that can go in the block of a screen language statement. The first kind of line is a keyword parameter line, which consists of one or more space-separated keyword parameters. The second is a screen language statement, that defines a widget to be placed within this one. As a matter of good style, all optional parameters in a block should be placed before the first screen language statement in that block, but Ren'Py does not enforce this restriction.


'''Relative Placement.''' When a child widget is contained within a parent widget, it is positioned relative to the area offered to it by the parent widget.


'''child-fixed Placement.''' Several widgets place their children using child-fixed placement. This means that:

* If the widget has exactly one child widget, then the child is added directly.
* Otherwise, a fixed layout is added to the widget, and the children are added to the child widget. Since a fixed widget will expand to consume all space, it will often be necessary to allocate a particular amount of space using ''area'' or other style properties.



'''Namespaces.''' When screens execute python code, they execute it in a context that consists of three namespaces:

# The local namespace contains parameters passed in when the scene is shown, and variables updated over the course of displaying the scene. This is the only namespace that can be updated when displaying the scene.
# The scene language namespace contains the Actions and Adjustments given below. This namespace is available as the sl module, which is imported into the default Ren'Py namespace.
# The default Ren'Py namespace, which is the namespace where Python variables are stored by default.

When a variable is accessed, the namespaces are searched in order.




== Common Keyword Arguments ==

There are several kinds of keyword arguments that are common to many of the screen language statements. We define those keyword arguments here, so we don't have to repeat them for each statement below.

''id'' - (string) The id argument is used to assign a name to the widget created by this statement. This has two purposes. The first is to make the widget available to the code that displays the screen. The second is to allow the code that displays the screen to associate additional style information with the widget.

For example, a screen that's used for dialogue is expected to have widgets with the ids of "who", "what", and "window" defined. These widgets receive style information from the Character class. The "what" widget is also used to pause dialogue, and to inform the auto-forward mode how much dialogue is being displayed.

''at'' - (comma-separated list of simple expressions) The at statement is used to specify a list of transforms that are applied to the widget before being added to its parent. The transforms are applied to the widget in a left-to-right order, which means that the rightmost transform takes priority.

''style'' - (simple expression) This is evaluated to yield a style, which is used for the widget. The style may be:

* A string, in which case it is the style name.
* A style object, of the form style.style_name.


=== Style Properties ===

Many widgets also take style properties from one or more style property groups as keyword arguments. Each keyword argument should consist of a style property prefix and style property name. These property arguments are used to override aspects of the default widget style.

The ''area'' property is quite useful for screen language widgets, as it allows them to be positioned and sized on the screen.


== Declaring Screens ==

The screen statement is used to declare a screen. The screen statement is a statement in the Ren'Py script language, rather than the screen language proper. It is parsed using screen language rules.

The screen statement takes two positional argument:

* The first argument is optional. If present, it should be an integer, which gives the init level that the statement runs at, when the screen statement is not inside an init statement.
* The second argument is mandatory. It is a name, that gives the name of the screen that is being defined.

The root widget of a screen is a fixed layout. The fixed layout is implicitly created when the screen is; child widgets are added to the fixed layouts.

A screen takes the following optional common keyword arguments, which are applied to the fixed layout within it:

* ''id''
* ''at''
* ''style'' (defaults to "screen")
* Position Style Properties


== Imagemap Widget Statements ==

The screen language contains three statements that work with imagemaps. The imagemap statement is used to declare an imagemap, optionally placing a base image onto the screen. The hotspot and hotbar statements are used to declare areas of the images that the user can interact with.


=== imagemap ===

The imagemap statement is used to declare an imagemap. The imagemap is used by hotspots and hotbars that are contained within the imagemap. 

''auto'' - (string) A string that is used to generate default values for all of the other imagemap parameters. The string is expected to contain %s in it. For each of the parameters given below, the %s is replaced with the parameter name. If the file exists, it becomes the value of the parameter. Auto conflicts with the rest of the keyword parameters.

''ground'' - (Displayable) Used for parts of the imagemap that are not part of a hotspot or hotbar.

''insensitive'' - (Displayable) Used for hotspots and hotbars that are insensitive. Defaults to ''ground''.

''idle'' - (Displayable) Used for unfocused unselected hotspots, and the empty part of unfocused hotbars. Defaults to ''ground''.

''hover'' - (Displayable) Used for focused unselected hotspots, and the empty part of focused hotbars. Defaults to ''ground''.

''selected_idle'' - (Displayable) Used for unfocused selected hotspots, and for the filled part of unfocused hotbars. Defaults to ''idle''. 

''selected_hover'' - (Displayable) Used for focused selected hotspots, and for the filled part of focused hotbars. Defaults to ''idle''. 

An imagemap is really a fixed layout that images are added to. As such, it can contain any widget, but hotspots and hotbars are the most useful. 

The imagemap statement takes the following optional common keyword arguments:

* ''id''
* ''at''
* ''style'' (defaults to "imagemap")
* Position Style Properties


== Non-Imagemap Widget Statements ==

These statements declare widgets that do not use an imagemap.


=== text ===

The text statement is used to show text. The text statement takes a single mandatory positional argument, a simple_expression giving the text to show on the screen.

The text statement takes the following optional common keyword arguments:

* ''id''
* ''at''
* ''style'' (defaults to "default")
* Position Style Properties
* Text Style Properties

Text cannot contain child widgets.


=== button ===

The button statement is used to create a button the user can focus and activate. It takes no positional arguments. It takes the following optional keyword arguments:

''clicked'' - (Action) The action to take when the button is activated. The clicked action is also used to determine of if the button should be styled in a selected, normal, or insensitive style.

''hovered'' - (Action) The action to take when the button gains focus.

''unhovered'' - (Action) The action to take when the button loses focus. 

''keymap'' - (dict of key to Action) The keymap that is in place when the button is focused. When the given key is pressed, the action is run. The keys of the dictionary are either keysyms (like "mouseup_1", "K_F1", or "m") or key bindings defined in config.keymap (like "skip" or "save_delete").

The button statement takes the following optional common keyword arguments:

* ''id''
* ''at''
* ''style'' (defaults to "button")
* Position Style Properties
* Window Style Properties
* Button Style Properties

A button may have any number of children, using child-fixed placement.


=== textbutton ===

The textbutton statement is used to create a button containing text in a single declaration. It takes a single mandatory positional argument, a simple_expression giving the text to display in the button. 

These optional keyword arguments are given the same meaning as they have in the button statement:

* ''clicked''
* ''hovered''
* ''unhovered''
* ''keymap''

The textbutton statement takes the following optional common keyword arguments:

* ''id''
* ''at''
* ''style'' (defaults to "button")
* Position Style Properties
* Window Style Properties
* Button Style Properties

When the ''style'' argument is a string, the style of the text contained within the button is set to style + "_text". For example, if the style is "button", then the text is given the style "button_text".

A textbutton cannot have any child widgets.


=== hbox ===

The hbox statement creates a box that lays out its child widgetshorizontally. It takes no positional arguments. It takes the following optional common keyword arguments:

* ''id''
* ''at''
* ''style'' (defaults to "hbox")
* Position Style Properties
* Box Style Properties

A hbox is expected to have one or more child widgets.


=== vbox ===

The vbox statement creates a box that lays out its child widgets horizontally. It takes no positional arguments. It takes the following optional common keyword arguments:

* ''id''
* ''at''
* ''style'' (defaults to "hbox")
* Position Style Properties
* Box Style Properties

A vbox is expected to have one or more child widgets.


=== fixed ===

The fixed statement creates a box that lays out its child widgets according to the position provided by the child widget. It takes no positional arguments. It takes the following optional common keyword arguments:

* ''id''
* ''at''
* ''style'' (defaults to "hbox")
* Position Style Properties
* Box Style Properties

A fixed layout is expected to have one or more child widgets.


=== window/frame === 

The window and frame statements create windows that can contain the other widget. The only difference between the two statements is the default style. The window statement uses a style that is appropriate for the display of in-game text, while the frame statement uses a style that is designed to contain user-interface widgets.

These statements do not take positional arguments. They take the following optional common keyword arguments:

* ''id''
* ''at''
* ''style'' (defaults to "hbox")
* Position Style Properties
* Window Style Properties

Windows and frames can have any number of children, using child-fixed placement.


=== key ===

The key statement creates a keybinding that causes an action to occur when the key is pressed. It takes one positional argument, the name of the keysym. It takes the following optional keyword argument:

''action'' - (Action) An action to run when the key is pressed.

The key statement is useless if an action argument is not defined. Keys cannot have child widgets.




transform

input
image

hotspot
hotbar

imagebutton
bar 
slider?
vbar
vslider
autobar?
timer

== Screen Language Control Statements ==

== Actions ==

== Adjustments ==

== Using Screens ==

== Python Equivalent ==

  button area (100, 200, 100, 200)
